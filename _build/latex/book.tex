%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduzione alla programmazione}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Introduzione alla programmazione per le scuole superiori}
\date{Nov 07, 2024}
\release{}
\author{basics}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
Questo libro fa parte del materiale pensato per \sphinxhref{https://basics2022.github.io/bbooks-hs}{le scuole superiori}

\sphinxAtStartPar
\sphinxstylestrong{Obiettivi generali.} Questo lavoro punta ad essere un’opera di \sphinxstyleemphasis{formazione alla} \sphinxstylestrong{tirchieria}, \sphinxstylestrong{prigrizia} \sphinxstyleemphasis{e} \sphinxstylestrong{onestà}, almeno in ambito informatico. I più benvolenti potranno riassumere questo obiettivo come il desiderio di \sphinxstyleemphasis{non buttare nel WC soldi, tempo, e pazienza}.

\sphinxAtStartPar
Oltre alle nozioni minime, l’obiettivo principale di questo libro è la formazione a:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{indipendenza} in ambito informatico: evitare di pagare per qualcosa che non serve; evitare di pagare per qualcosa di inutile o dannoso in presenza di alternative libere; meglio dedicare le risorse a ciò che vale la pena pagare

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ordine}: i moderni strumenti informatici permettono di lavorare in maniera ordinata, risparmiando tempo, soldi e pazienza

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{trasparenza} e \sphinxstylestrong{onestà}: anche se spesso in maniera non lineare, la conoscenza procede seguendo il metodo scientifico: i risultati mostrati e le tesi proposte devono essere supportate da dati e logica; i dati e le analisi svolte per poter produrre risultati devono essere disponibili, controllabili e soggetti a critica. Tutto il resto, almeno qui, almeno nell’ambito della conoscenza che procede con il metodo scientifico, sarà considerata confusione nella migliore delle ipotesi o direttamente \sphinxstyleemphasis{merda}.

\end{itemize}



\sphinxAtStartPar
\sphinxstylestrong{Metodo.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Impostazione degli strumenti necessari.} \sphinxstylestrong{todo}…

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Linguaggio di programmazione.} In questa introduzione si sceglie di usare \sphinxstylestrong{Python} come linguaggio di programmazione.
Un approccio più generale all’informatica e alla programmazione prevederebbe l’utilizzo di altri linguaggio di programmazione (come C).
Considerata la \sphinxstylestrong{diffusione} di Python, la quantità di \sphinxstylestrong{librerie disponibili} (con eventuali binding a librerie sviluppate usando linguaggi di programmazione più efficienti) e strumenti per la \sphinxstylestrong{programmazione collaborativa} e remota (\sphinxstylestrong{Colab}, \sphinxstylestrong{Jupyter},…), Python risulta comunque una buona scelta per un corso improntato alla presentazione delle basi di programmazione dirette a un’applicazione abbastanza immediata.

\sphinxAtStartPar
Verranno posta attenzione sulla sintassi “particolare” di Python quando si discosta maggiormente dagli altri linguaggi di programmazione.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Argomenti.} \sphinxstylestrong{todo}…

\end{itemize}

\sphinxstepscope


\part{Introduzione alla programmazione}

\sphinxstepscope


\chapter{Introduzione alla programmazione \sphinxhyphen{} in Python}
\label{\detokenize{ch/programming:introduzione-alla-programmazione-in-python}}\label{\detokenize{ch/programming:book-programming-intro-hs}}\label{\detokenize{ch/programming::doc}}
\sphinxAtStartPar
L’introduzione alla programmazione in Python userà le risorse messe a disposizione da \sphinxhref{https://www.google.com}{Google} con il progetto \sphinxhref{https://jupyter.org}{Jupyter} per lo sviluppo di codice open\sphinxhyphen{}source, con open\sphinxhyphen{}standard e servizi interattivi utilizzabili su diversi dispositivi usando diversi linguaggi di programmazione, come \DUrole{xref,myst}{Python}, \sphinxhref{https://julialang.org}{Julia} o \sphinxhref{https://www.r-project.org}{R}

\sphinxAtStartPar
Oltre al dispositivo elettronico utilizzato per consultare al materiale, non è necessario nessun altro dispositivo informatico: un account Google personale permette l’accesso libero ai servizi base di cloud computing di \sphinxhref{https://colab.research.google.com}{Colab}

\sphinxstepscope


\chapter{Tipi}
\label{\detokenize{ch/programming/types:tipi}}\label{\detokenize{ch/programming/types::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
tipi

\item {} 
\sphinxAtStartPar
variabili
\begin{itemize}
\item {} 
\sphinxAtStartPar
…

\item {} 
\sphinxAtStartPar
by\sphinxhyphen{}reference o by\sphinxhyphen{}value

\end{itemize}

\end{itemize}

\sphinxstepscope


\chapter{Controllo del flusso}
\label{\detokenize{ch/programming/flow_control:controllo-del-flusso}}\label{\detokenize{ch/programming/flow_control::doc}}
\sphinxAtStartPar
Nei paradigmi di \sphinxstyleemphasis{programmazione imperativa} (\sphinxstylestrong{todo} fare riferimento ai paradigmi di programmazione. Ha senso questa distinzione?), vengono usate delle strutture di controllo del flusso di esecuzione di un programma.

\sphinxAtStartPar
Si possono distinguere due categorie delle strutture di controllo:
\begin{itemize}
\item {} 
\sphinxAtStartPar
alternativa: if\sphinxhyphen{}then, if\sphinxhyphen{}then\sphinxhyphen{}else

\item {} 
\sphinxAtStartPar
iterazione: for, while, …

\end{itemize}


\section{Alternativa}
\label{\detokenize{ch/programming/flow_control:alternativa}}

\subsection{if\sphinxhyphen{}then e if\sphinxhyphen{}then\sphinxhyphen{}else}
\label{\detokenize{ch/programming/flow_control:if-then-e-if-then-else}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Test if\PYGZhy{}then \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.1}

\PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{odd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} automatic casting into an int \PYGZhy{}\PYGZgt{} a \PYGZpc{} 2 = floor(a) \PYGZpc{} 2}
    \PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{even}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) is an }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{word}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (2.1) is an odd number
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Test if\PYGZhy{}then\PYGZhy{}else \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{15.7}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{elif} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{0}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{). }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ \PYGZpc{} 3 = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{reminder}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (15.7). 15.7 \PYGZpc{} 3 = 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{switch}
\label{\detokenize{ch/programming/flow_control:switch}}

\section{Iterazione}
\label{\detokenize{ch/programming/flow_control:iterazione}}

\subsection{for loop}
\label{\detokenize{ch/programming/flow_control:for-loop}}

\subsection{while loop}
\label{\detokenize{ch/programming/flow_control:while-loop}}

\subsection{altri cicli}
\label{\detokenize{ch/programming/flow_control:altri-cicli}}
\sphinxstepscope


\chapter{Funzioni}
\label{\detokenize{ch/programming/functions:funzioni}}\label{\detokenize{ch/programming/functions::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a function to tell if a number is positive or not}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function returning True if x\PYGZgt{}0, False if x\PYGZlt{}=0 \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} User input to test the function: tuple of numbers}
\PYG{n}{n\PYGZus{}tuple} \PYG{o}{=} \PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{.003}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.4} \PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Test function on all the elements in the user\PYGZhy{}defined tuple}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{n\PYGZus{}tuple}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:} 
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{not }\PYG{l+s+s1}{\PYGZsq{}}
        
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{string}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{positive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1 is not positive
2.0 is positive
0.003 is positive
0.3333333333333333 is positive
\PYGZhy{}2.2 is not positive
0 is not positive
\PYGZhy{}7.4 is not positive
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Default value of function arguments}
\label{\detokenize{ch/programming/functions:default-value-of-function-arguments}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a user function to tell is the first argument is greater than the second.}
\PYG{c+c1}{\PYGZsh{} If no second argument is given, it\PYGZsq{}s set = 0 (default value, defined in the function)}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than  0 ? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{,    ):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Is \PYGZhy{}2 greater than \PYGZhy{}3? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2, \PYGZhy{}3):True
Is \PYGZhy{}2 greater than  0 ? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2,    ):False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Classi}
\label{\detokenize{ch/programming/oo:classi}}\label{\detokenize{ch/programming/oo::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
classi, metodi, oggetti

\item {} 
\sphinxAtStartPar
ereditarietà, overloading

\end{itemize}

\sphinxstepscope


\chapter{Librerie}
\label{\detokenize{ch/programming/libraries:librerie}}\label{\detokenize{ch/programming/libraries::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Definizione del concetto

\item {} 
\sphinxAtStartPar
librerie “standard”, scritte da qualcun’altro

\item {} 
\sphinxAtStartPar
scrivere una libreria

\end{itemize}

\sphinxstepscope


\part{Introduzione al calcolo numerico}

\sphinxstepscope


\chapter{Introduzione al calcolo scientifico}
\label{\detokenize{ch/numerics:introduzione-al-calcolo-scientifico}}\label{\detokenize{ch/numerics:book-numerics-hs}}\label{\detokenize{ch/numerics::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Equazioni lineari

\item {} 
\sphinxAtStartPar
Equazioni non lineari

\item {} 
\sphinxAtStartPar
Approssimazione di funzioni

\item {} 
\sphinxAtStartPar
Derivate

\item {} 
\sphinxAtStartPar
Integrali

\item {} 
\sphinxAtStartPar
Equazioni differenziali ordinarie:
\begin{itemize}
\item {} 
\sphinxAtStartPar
problema di Cauchy ai valori iniziali

\item {} 
\sphinxAtStartPar
problema ai valori al contorno

\end{itemize}

\item {} 
\sphinxAtStartPar
Ottimizzazione, vincolata e non

\end{itemize}

\sphinxstepscope


\section{Sistemi lineari}
\label{\detokenize{ch/numerics/linear:sistemi-lineari}}\label{\detokenize{ch/numerics/linear::doc}}
\sphinxAtStartPar
La soluzione di sistemi lineari è un problema che compare in molte altre applicazioni di calcolo numerico …

\sphinxAtStartPar
Esistono due grandi classi di metodi/algoritmi per la soluzione di sistemi lineari:
\begin{itemize}
\item {} 
\sphinxAtStartPar
i metodi diretti, che si basano su una fattorizzazione della matrice

\item {} 
\sphinxAtStartPar
i metodi indiretti, che si basano sul calcolo di prodotti matrice\sphinxhyphen{}vettore

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{todo}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Riferimento alla sezione di matematica sull’\sphinxstylestrong{algebra lineare} per dare le basi: cos’è un sistema lineare? Come può essere scritto usando il formalismo matriciale? Caratteristiche principali di una matrice (rango, nucleo, spettro, …)

\item {} 
\sphinxAtStartPar
Riferimento ai problemi numerici: condizionamento?

\end{itemize}

\sphinxstepscope


\section{Problemi non lineari}
\label{\detokenize{ch/numerics/nonlinear:problemi-non-lineari}}\label{\detokenize{ch/numerics/nonlinear::doc}}

\subsection{Metodo di bisezione}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-bisezione}}
\sphinxAtStartPar
Il metodo di bisezione per la ricerca degli zeri di una funzione continua \(F(x)\) si basa sul teorema dei valori intermedi per le funzioni continue.

\sphinxAtStartPar
Dati due numeri reali \(a\), \(b\) tali che \(f(a) \, f(b) < 0\), allora esiste un punto \(c \in (a,b)\) tale che \(f(c) = 0\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example of bisection method}

\PYG{l+s+sd}{Find the solution of the problem f(x) = 0}
\PYG{l+s+sd}{with f(x) = e\PYGZca{}x \PYGZhy{} x}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{time}

\PYG{c+c1}{\PYGZsh{} Function f and its derivative}
\PYG{n}{f}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}
\PYG{n}{df} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Parameters of the bi\PYGZhy{}section method}
\PYG{n}{tol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}
\PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{l+m+mi}{100}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Find 2 values so that \PYGZdl{}f(a) f(b) \PYGZlt{} 0\PYGZdl{}}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{0.}
\PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{k}{if} \PYG{p}{(} \PYG{o+ow}{not} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection algorithm can}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t start, f(a)f(b)\PYGZgt{}= 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
    \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fx}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        
        \PYG{k}{if} \PYG{p}{(} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,c]}
            \PYG{n}{b} \PYG{o}{=} \PYG{n}{x}
        \PYG{k}{else}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,b]}
            \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}
        
        \PYG{c+c1}{\PYGZsh{} Update solution and residual}
        \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
        \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Update n.iter}
        \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}            
        
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection method summary}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{solution, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{res  : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{niter: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{etime: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{res: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bisection method summary
solution, x = \PYGZhy{}0.567143440246582
res  : \PYGZhy{}2.348157265297246e\PYGZhy{}07
niter: 20
etime: 0.0008769035339355469
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Metodo di Newton}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-newton}}
\sphinxAtStartPar
Per trovare la soluzione del problema non lineare
\begin{equation*}
\begin{split}F(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
il metodo di Newton sfrutta l’espansione in serie troncata al primo grado della funzione \(F(x)\), per scrivere
\begin{equation*}
\begin{split}0 = F(x^n + \Delta x) \approx F(x^n) + F'(x^n) \Delta x \end{split}
\end{equation*}
\sphinxAtStartPar
e ottenere l’incremento della soluzione \(\Delta x\) come soluzione del sistema lineare
\begin{equation*}
\begin{split}F'(x^n) \Delta x = -F(x^n)\end{split}
\end{equation*}
\sphinxAtStartPar
e aggiornare la soluzione \(x^{n+1} = x^{n} + \Delta x\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example of Newton method}

\PYG{l+s+sd}{Find the solution of the problem f(x) = 0}
\PYG{l+s+sd}{with f(x) = e\PYGZca{}x \PYGZhy{} x}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} import numpy as np (already imported?)}

\PYG{c+c1}{\PYGZsh{} \PYGZsh{} Function f and its derivative (already defined?)}
\PYG{c+c1}{\PYGZsh{} f  = lambda x: np.exp(x) + x}
\PYG{c+c1}{\PYGZsh{} df = lambda x: np.exp(x) + 1}

\PYG{c+c1}{\PYGZsh{} Parameters of the Newton method, for stopping criteria}
\PYG{n}{tol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}          \PYG{c+c1}{\PYGZsh{} tolerance on the residual |f(x)| \PYGZlt{} tol}
\PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{l+m+mi}{10}      \PYG{c+c1}{\PYGZsh{} max n. of iterations      niter \PYGZgt{} max\PYGZus{}niter}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Initial guess, residual and number of iterations}
\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{} Newton algorithm}
\PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Solve linear approximation step, and update solution}
    \PYG{n}{dx} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{res} \PYG{o}{/} \PYG{n}{df}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dx}

    \PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate new residual and n. of iter}
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton method summary}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{solution, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{res  : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{niter: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{etime: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{res: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{etime: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Newton method summary
solution, x = \PYGZhy{}0.567143285989123
res  : 6.927808993140161e\PYGZhy{}09
niter: 3
etime: 0.0005042552947998047
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Approssimazione di funzioni}
\label{\detokenize{ch/numerics/approximation:approssimazione-di-funzioni}}\label{\detokenize{ch/numerics/approximation::doc}}

\subsection{Interpolazione}
\label{\detokenize{ch/numerics/approximation:interpolazione}}

\subsection{Regressione}
\label{\detokenize{ch/numerics/approximation:regressione}}
\sphinxstepscope


\section{Derivate di funzioni}
\label{\detokenize{ch/numerics/derivatives:derivate-di-funzioni}}\label{\detokenize{ch/numerics/derivatives::doc}}

\subsection{Differenze finite}
\label{\detokenize{ch/numerics/derivatives:differenze-finite}}
\sphinxAtStartPar
Il calcolo della derivata di una funzione \(f(x)\) derivabile in un punto \(x_0\) può essere svolto utilizzando l’espansione locale in serie di Taylor di una funzione.


\subsubsection{Derivata prima}
\label{\detokenize{ch/numerics/derivatives:derivata-prima}}
\sphinxAtStartPar
Usando le espansioni
\begin{equation*}
\begin{split}f(x + \Delta x) = f(x) + f'(x) \Delta x + f''(x) \frac{\Delta x^2}{2} + f'''(x) \frac{\Delta x^3}{3!} + o(x^3)\end{split}
\end{equation*}\begin{equation*}
\begin{split}f(x - \Delta x) = f(x) - f'(x) \Delta x + f''(x) \frac{\Delta x^2}{2} - f'''(x) \frac{\Delta x^3}{3!} + o(x^3)\end{split}
\end{equation*}
\sphinxAtStartPar
si possono ricavare gli schemi del primo ordine
\begin{equation*}
\begin{split}f'(x) = \frac{f(x+\Delta x) - f(x)}{\Delta x} + o(\Delta x)\end{split}
\end{equation*}\begin{equation*}
\begin{split}f'(x) = \frac{f(x+\Delta x) - f(x)}{\Delta x} + o(\Delta x)\end{split}
\end{equation*}
\sphinxAtStartPar
e lo schema del secondo ordine usando le differenze centrate
\begin{equation*}
\begin{split}f'(x) = \dfrac{f(x+\Delta x) - f(x-\Delta x)}{2 \Delta x} + o(\Delta x^2) \end{split}
\end{equation*}

\subsubsection{Derivata seconda}
\label{\detokenize{ch/numerics/derivatives:derivata-seconda}}
\sphinxAtStartPar
Usando le stesse espansioni in serie, si può ottenere uno schema del secondo ordine per la derivata seconda
\begin{equation*}
\begin{split}f''(x) = \frac{f(x+\Delta x) - 2 f(x) + f(x-\Delta x)}{\Delta x^2} + o(\Delta x^2)\end{split}
\end{equation*}
\sphinxstepscope


\section{Integrali}
\label{\detokenize{ch/numerics/integrals:integrali}}\label{\detokenize{ch/numerics/integrals::doc}}

\subsection{Integrazione di Newton\sphinxhyphen{}Cotes}
\label{\detokenize{ch/numerics/integrals:integrazione-di-newton-cotes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Formula del punto medio

\item {} 
\sphinxAtStartPar
Formula del trapezio

\end{itemize}


\subsection{Integrazione di Gauss}
\label{\detokenize{ch/numerics/integrals:integrazione-di-gauss}}
\sphinxAtStartPar
L’integrazione di Gauss permette di calcolare in maniera esatta l’integrale di una funzione polinomiale \(p^(n)(x)\) su un intervallo \([a,b]\), come somma pesata della funzione valuatata in alcuni punti dell’intervallo,
\begin{equation*}
\begin{split}\int_a^b p^{(n)}(x) dx = \sum_{g} w_g f(x_g) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Per motivi di generalizzazione dell’algoritmo, nella definizione dei \sphinxstylestrong{pesi} \(w_i\) e dei \sphinxstylestrong{nodi di Gauss} \(x_i\), l’integrale viene riportato all’integrale su un intervallo di riferimento, tramite una trasformazione di coordinate.

\sphinxAtStartPar
Per domini 1D, l’intervallo di riferimento per la quadratura di Gauss è l’intervallo \(\xi = [-1, 1]\) e il cambio di variabili è
\begin{equation*}
\begin{split}x = \frac{a+b}{2} + \frac{b-a}{2}(\xi - 1) \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
così che l’integrale originale può essere scritto come
\begin{equation*}
\begin{split}\begin{aligned}
\int_{x=a}^b p^{(n)}(x) dx & = \int_{\xi = -1}^{1} p^(n) (x(\xi)) \dfrac{d x}{d\xi} d \xi = \\
 & = \dfrac{b-a}{2} \int_{\xi=-1}^{1} p^{(n)}(x(\xi)) d \xi = \dfrac{b-a}{2} \sum_{g} w_g \, p^{(n)}\left(x(\xi_g)\right)
\end{aligned}\end{split}
\end{equation*}
\sphinxstepscope


\section{Equazioni differenziali ordinarie}
\label{\detokenize{ch/numerics/ode:equazioni-differenziali-ordinarie}}\label{\detokenize{ch/numerics/ode::doc}}
\sphinxstepscope


\subsection{Problemi di Cauchy ai valori iniziali}
\label{\detokenize{ch/numerics/ode-cauchy:problemi-di-cauchy-ai-valori-iniziali}}\label{\detokenize{ch/numerics/ode-cauchy::doc}}

\subsubsection{Approccio a un problema di Cauchy di ordine \protect\(n\protect\)}
\label{\detokenize{ch/numerics/ode-cauchy:approccio-a-un-problema-di-cauchy-di-ordine-n}}
\sphinxAtStartPar
Un problema di Cauchy di ordine \(n\)
\begin{equation*}
\begin{split}\begin{cases}
  F(y^{(n)}(x), y^{(n-1)}(x), \dots, y'(x), y(x), x) = 0 \\
  y(x_0) = y^0 \\
  y'(x_0) = y'^0 \\
  \dots \\
  y^{(n-1)}(x_0) = y^{(n-1),0}
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
con funzione incognita \(y(x): D \in \mathbb{R} \rightarrow \mathbb{R}\), può essere riscritto come un problema di \sphinxstyleemphasis{“ordine 1”} per la funzione incognita \(\mathbf{z}(x): D \in \mathbb{R} \rightarrow \mathbb{R}^n\), definita come
\begin{equation*}
\begin{split}\mathbf{z}(x) = (z_0(x), z_1(x), \dots z_{n-1}(x)) := (y(x), y'(x), \dots, y^{(n-1)}(x)) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Esplicitando le relazioni tra le componenti di \(\mathbf{z}(x)\) e le derivate della funzione \(y(x)\), \(z_{k}(x) = y^{(k)}(x) = {y^{(k-1)}}'(x) = z'_{k-1}(x)\), il problema di Cauchy può essere riformulato come
\begin{equation*}
\begin{split}\begin{cases}
z'_0 - z_1 = 0 \\
z'_1 - z_2 = 0 \\
\dots \\
z'_{n-2} - z_{n-1} = 0 \\
F(z'_{n-1}(x), z_{n-1}(x), \dots, z_1(x), z_0(x)) = 0 \ ,
\end{cases}
\qquad , \qquad
\text{i.c.} \quad
\begin{cases}
z_0(x_0) = y^0 \\
z_1(x_0) = y'^0 \\
\dots \\
z_{n-1}(x_0) = y^{(n-1),0}
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
che può essere riscritto con il formalismo vettoriale come
\begin{equation*}
\begin{split}\begin{cases}
  \mathbf{F}(\mathbf{z}'(x), \mathbf{z}) = \mathbf{0} \\
  \mathbf{z}(x_0) = \mathbf{z}_0
\end{cases}\end{split}
\end{equation*}

\subsubsection{Caratteristiche (cenni)}
\label{\detokenize{ch/numerics/ode-cauchy:caratteristiche-cenni}}\begin{itemize}
\item {} 
\sphinxAtStartPar
accuratezza, consistenza, convergenza

\item {} 
\sphinxAtStartPar
stabilità: 0\sphinxhyphen{}, A\sphinxhyphen{} condizionata e incondizionata

\end{itemize}


\subsubsection{Schemi numerici}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici}}

\paragraph{Schemi numerici a un passo}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-a-un-passo}}

\paragraph{Schemi numerici multi\sphinxhyphen{}step}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-multi-step}}
\sphinxstepscope


\subsection{Problemi al contorno}
\label{\detokenize{ch/numerics/ode-boundary:problemi-al-contorno}}\label{\detokenize{ch/numerics/ode-boundary::doc}}

\subsubsection{Differenze finite}
\label{\detokenize{ch/numerics/ode-boundary:differenze-finite}}

\subsubsection{Elementi finiti}
\label{\detokenize{ch/numerics/ode-boundary:elementi-finiti}}

\subsubsection{Volumi finiti}
\label{\detokenize{ch/numerics/ode-boundary:volumi-finiti}}
\sphinxstepscope


\section{Ottimizzazione}
\label{\detokenize{ch/numerics/optimization:ottimizzazione}}\label{\detokenize{ch/numerics/optimization::doc}}
\sphinxAtStartPar
Le tecniche di ottimizzazione sono alla base di molti metodi di interesse, dall’approssimazione di funzioni, alla regolazione e controllo, agli algoritmi usati in intelligenza artificiale

\sphinxstepscope


\section{Introduzione ai metodi in AI}
\label{\detokenize{ch/ai:introduzione-ai-metodi-in-ai}}\label{\detokenize{ch/ai:book-ai-hs}}\label{\detokenize{ch/ai::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
SL, supervised learning: regression and classification

\item {} 
\sphinxAtStartPar
UL, unsupervised learning: clustering

\item {} 
\sphinxAtStartPar
ML, machine learning: control

\end{itemize}

\sphinxstepscope


\part{Supporto tecnico}

\sphinxstepscope


\chapter{Supporto tecnico}
\label{\detokenize{ch/support:supporto-tecnico}}\label{\detokenize{ch/support:programming-hs-support-hs}}\label{\detokenize{ch/support::doc}}






\renewcommand{\indexname}{Index}
\printindex
\end{document}