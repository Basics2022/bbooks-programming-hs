%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,italian]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{italian}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsitalian{\renewcommand{\contentsname}{Introduzione alla programmazione}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Introduzione alla programmazione per le scuole superiori}
\date{06 dic 2024}
\release{}
\author{basics}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
Questo libro fa parte del materiale pensato per \sphinxhref{https://basics2022.github.io/bbooks-hs}{le scuole superiori}. E” disponibile la \sphinxhref{https://www.github.com/Basics2022/bbooks-programming-hs/blob/master/\_build/latex/book.pdf}{versione in .pdf} scaricabile.

\sphinxAtStartPar
\sphinxstylestrong{Obiettivi generali.} Questo lavoro punta ad essere un’opera di \sphinxstyleemphasis{formazione alla} \sphinxstylestrong{tirchieria}, \sphinxstylestrong{prigrizia} \sphinxstyleemphasis{e} \sphinxstylestrong{onestà}, almeno in ambito informatico. I più benvolenti potranno riassumere questo obiettivo come il desiderio di \sphinxstyleemphasis{non buttare nel WC soldi, tempo, e pazienza}.

\sphinxAtStartPar
Oltre alle nozioni minime, l’obiettivo principale di questo libro è la formazione a:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{indipendenza} in ambito informatico: evitare di pagare per qualcosa che non serve; evitare di pagare per qualcosa di inutile o dannoso in presenza di alternative libere; meglio dedicare le risorse a ciò che vale la pena pagare

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ordine}: i moderni strumenti informatici permettono di lavorare in maniera ordinata, risparmiando tempo, soldi e pazienza

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{trasparenza} e \sphinxstylestrong{onestà}: anche se spesso in maniera non lineare, la conoscenza procede seguendo il metodo scientifico: i risultati mostrati e le tesi proposte devono essere supportate da dati e logica; i dati e le analisi svolte per poter produrre risultati devono essere disponibili, controllabili e soggetti a critica. Tutto il resto, almeno qui, almeno nell’ambito della conoscenza che procede con il metodo scientifico, sarà considerata confusione nella migliore delle ipotesi o direttamente \sphinxstyleemphasis{merda}.

\end{itemize}

\sphinxAtStartPar
Questo stesso libro è scritto seguendo questi criteri: oltre al dispositivo elettronico usato per consultare il materiale (online o offline, una volta scaricato), non è necessaria la spesa per nessun altro dispositivo o infrastruttura informatica; i sorgenti del materiale è sviluppato localmente, ospitato e disponibile su \sphinxhref{https://github.com}{Github} all’indirizzo \sphinxurl{https://github.com/Basics2022/bbooks-programming-hs}.

\sphinxAtStartPar
\sphinxstylestrong{necessità di una connessione internet, se non si porta il progetto su un sistema locale, con tutti gli strumenti necessari \sphinxhyphen{} non tanti, e standard, ma comunque devono esserci «per funzionare»}



\sphinxAtStartPar
\sphinxstylestrong{Metodo.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Impostazione degli strumenti necessari.} \sphinxstylestrong{todo}…

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Linguaggio di programmazione.} In questa introduzione si sceglie di usare \sphinxstylestrong{Python} come linguaggio di programmazione.
Un approccio più generale all’informatica e alla programmazione prevederebbe l’utilizzo di altri linguaggio di programmazione (come C).
Considerata la \sphinxstylestrong{diffusione} di Python, la quantità di \sphinxstylestrong{librerie disponibili} (con eventuali binding a librerie sviluppate usando linguaggi di programmazione più efficienti) e strumenti per la \sphinxstylestrong{programmazione collaborativa} e remota (\sphinxstylestrong{Colab}, \sphinxstylestrong{Jupyter},…), Python risulta comunque una buona scelta per un corso improntato alla presentazione delle basi di programmazione dirette a un’applicazione abbastanza immediata.

\sphinxAtStartPar
Verranno posta attenzione sulla sintassi «particolare» di Python quando si discosta maggiormente dagli altri linguaggi di programmazione.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Argomenti.} \sphinxstylestrong{todo}…

\end{itemize}

\sphinxstepscope


\part{Introduzione alla programmazione}

\sphinxstepscope


\chapter{Introduzione alla programmazione \sphinxhyphen{} in Python}
\label{\detokenize{ch/programming:introduzione-alla-programmazione-in-python}}\label{\detokenize{ch/programming:book-programming-intro-hs}}\label{\detokenize{ch/programming::doc}}
\sphinxAtStartPar
L’introduzione alla programmazione in Python userà le risorse messe a disposizione da \sphinxhref{https://www.google.com}{Google} con il progetto \sphinxhref{https://jupyter.org}{Jupyter} per lo sviluppo di codice open\sphinxhyphen{}source, con open\sphinxhyphen{}standard e servizi interattivi utilizzabili su diversi dispositivi usando diversi linguaggi di programmazione, come \sphinxhref{https://python.org}{Python}, \sphinxhref{https://julialang.org}{Julia} o \sphinxhref{https://www.r-project.org}{R}

\sphinxAtStartPar
Oltre al dispositivo elettronico utilizzato per consultare al materiale, non è necessario nessun altro dispositivo informatico: un account Google personale permette l’accesso libero ai servizi base di cloud computing di \sphinxhref{https://colab.research.google.com}{Colab}

\sphinxstepscope


\chapter{Variabili, tipi e funzioni elementari built\sphinxhyphen{}in}
\label{\detokenize{ch/programming/types:variabili-tipi-e-funzioni-elementari-built-in}}\label{\detokenize{ch/programming/types::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
tipi

\item {} 
\sphinxAtStartPar
variabili
\begin{itemize}
\item {} 
\sphinxAtStartPar
…

\item {} 
\sphinxAtStartPar
by\sphinxhyphen{}reference o by\sphinxhyphen{}value

\end{itemize}

\end{itemize}


\section{Commenti}
\label{\detokenize{ch/programming/types:commenti}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} I commenti permettono di aggiungere brevi descrizione al codice}

\PYG{c+c1}{\PYGZsh{} In Python, è possibile aggiungerre commenti al codice con il carattere \PYGZsh{}: tutto quello}
\PYG{c+c1}{\PYGZsh{} che viene dopo il carattere \PYGZsh{} su una riga è considerato un commento, e non codice da}
\PYG{c+c1}{\PYGZsh{} eseguire}

\PYG{c+c1}{\PYGZsh{} E\PYGZsq{} buona regola aggiungere qualche commento al codice, e sarebbe bene iniziare a farlo}
\PYG{c+c1}{\PYGZsh{} in lingua inglese:}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} il codice non è auto\PYGZhy{}esplicativo!}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} il codice potrebbe essere usato da altri in giro per il mondo, ed è più probabile che}
\PYG{c+c1}{\PYGZsh{}   si conosca l\PYGZsq{}inglese invece dell\PYGZsq{}italiano}

\PYG{c+c1}{\PYGZsh{} So let\PYGZsq{}s switch to English for scripts, both for comments and \PYGZdq{}for variable names\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Comments are not documentation! **todo** Add some paragraph about documentation!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Tipi built\sphinxhyphen{}in}
\label{\detokenize{ch/programming/types:tipi-built-in}}\begin{itemize}
\item {} 
\sphinxAtStartPar
numero: intero, reale, complesso

\item {} 
\sphinxAtStartPar
booleano

\item {} 
\sphinxAtStartPar
stringa

\item {} 
\sphinxAtStartPar
bytes

\item {} 
\sphinxAtStartPar
lista

\item {} 
\sphinxAtStartPar
tupla

\item {} 
\sphinxAtStartPar
insieme

\item {} 
\sphinxAtStartPar
dizionario, \(\texttt{dict}\)

\end{itemize}


\subsection{Numeri}
\label{\detokenize{ch/programming/types:numeri}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Numbers}

\PYG{l+s+sd}{in Python, variables are not delcared. Thus, a number variable is not defined}
\PYG{l+s+sd}{as an integer, a real or a complex variable, but it\PYGZsq{}s type is inferred by its}
\PYG{l+s+sd}{initialization}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Numbers}
\PYG{n}{a\PYGZus{}int} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{a\PYGZus{}real} \PYG{o}{=} \PYG{l+m+mf}{1.}
\PYG{n}{a\PYGZus{}complex} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{+} \PYG{l+m+mf}{0.}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Strings}
\PYG{n}{a\PYGZus{}str} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.0}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}int)    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}int}\PYG{+w}{    }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}real)   : }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}real}\PYG{+w}{   }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}complex): }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}complex}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}str    ): }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}str}\PYG{+w}{    }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
type(a\PYGZus{}int)    : \PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}real)   : \PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}complex): \PYGZlt{}class \PYGZsq{}complex\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}str    ): \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Booleani \sphinxhyphen{} logici}
\label{\detokenize{ch/programming/types:booleani-logici}}

\subsection{Stringhe}
\label{\detokenize{ch/programming/types:stringhe}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Strings}

\PYG{l+s+sd}{strings are character }
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZbs{}nStrings\PYGZbs{}n\PYGZbs{}nstrings are character \PYGZbs{}n\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Liste, tuple e insiemi}
\label{\detokenize{ch/programming/types:liste-tuple-e-insiemi}}

\subsection{Dizionari}
\label{\detokenize{ch/programming/types:dizionari}}
\sphinxstepscope


\chapter{Controllo del flusso}
\label{\detokenize{ch/programming/flow_control:controllo-del-flusso}}\label{\detokenize{ch/programming/flow_control::doc}}
\sphinxAtStartPar
Nei paradigmi di \sphinxstyleemphasis{programmazione imperativa} (\sphinxstylestrong{todo} fare riferimento ai paradigmi di programmazione. Ha senso questa distinzione?), vengono usate delle strutture di controllo del flusso di esecuzione di un programma.

\sphinxAtStartPar
Si possono distinguere due categorie delle strutture di controllo:
\begin{itemize}
\item {} 
\sphinxAtStartPar
condizionale ed alternativa: if, if\sphinxhyphen{}then, if\sphinxhyphen{}then\sphinxhyphen{}else

\item {} 
\sphinxAtStartPar
iterazione: for, while, …

\end{itemize}


\section{Alternativa}
\label{\detokenize{ch/programming/flow_control:alternativa}}

\subsection{\protect\(\texttt{if}\protect\)\sphinxhyphen{}\protect\(\texttt{then}\protect\) statement}
\label{\detokenize{ch/programming/flow_control:texttt-if-texttt-then-statement}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} if\PYGZhy{}then example \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} Try this script changing the user input}

\PYG{c+c1}{\PYGZsh{} User input}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{2}        \PYG{c+c1}{\PYGZsh{} a is initialize as an integer}
\PYG{c+c1}{\PYGZsh{} a = 2.1      \PYGZsh{} if a is initialized as a real, a \PYGZpc{} 2 perform automatic casting, int(a) \PYGZpc{} 2}
               \PYG{c+c1}{\PYGZsh{} uncomment previous line and try!}

\PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{odd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} automatic casting into an int \PYGZhy{}\PYGZgt{} a \PYGZpc{} 2 = floor(a) \PYGZpc{} 2}
    \PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{even}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) is an }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{word}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (2) is an even number
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{\protect\(\texttt{if}\protect\)\sphinxhyphen{}\protect\(\texttt{then}\protect\)\sphinxhyphen{}\protect\(\texttt{else}\protect\) statement}
\label{\detokenize{ch/programming/flow_control:texttt-if-texttt-then-texttt-else-statement}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} if\PYGZhy{}then\PYGZhy{}else example\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} Try this script changing the user input}

\PYG{c+c1}{\PYGZsh{} User input}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{15}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{p}{:}     \PYG{c+c1}{\PYGZsh{} First condition}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{elif} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} Other condition}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}                  \PYG{c+c1}{\PYGZsh{} All the other conditions}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{0}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{). }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ \PYGZpc{} 3 = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{reminder}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (15). 15 \PYGZpc{} 3 = 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}



\section{Iterazione}
\label{\detokenize{ch/programming/flow_control:iterazione}}

\subsection{for loop}
\label{\detokenize{ch/programming/flow_control:for-loop}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} for loop examples}

\PYG{l+s+sd}{Loops over:}
\PYG{l+s+sd}{\PYGZhy{} elements of a list}
\PYG{l+s+sd}{\PYGZhy{} elements in range}
\PYG{l+s+sd}{\PYGZhy{} keys, values of a dict}
\PYG{l+s+sd}{\PYGZhy{} ...}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a list}
\PYG{n}{seq} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{4.} \PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{key}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the list: seq = }\PYG{l+s+si}{\PYGZob{}seq\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{el} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{element }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ has type }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{el}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a tuple}
\PYG{c+c1}{\PYGZsh{} ...}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a range}
\PYG{n}{n\PYGZus{}el} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{range\PYGZus{}el} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the list, seq = }\PYG{l+s+si}{\PYGZob{}seq\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{range(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) has type: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{range\PYGZus{}el}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{range(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{range\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{range\PYGZus{}el}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Loop over keys, values of a dict}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k+kc}{True}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the dict, d = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{d}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{d}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Loop over elements of the list: seq = \PYGZob{}seq\PYGZcb{}
element a has type \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}
element 3 has type \PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}
element 4.0 has type \PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
element \PYGZob{}\PYGZsq{}key\PYGZsq{}: \PYGZsq{}value\PYGZsq{}\PYGZcb{} has type \PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{}

Loop over elements of the list, seq = \PYGZob{}seq\PYGZcb{}
range(5) has type: \PYGZlt{}class \PYGZsq{}range\PYGZsq{}\PYGZgt{}
range(5): range(0, 5)
0
1
2
3
4

Loop over elements of the dict, d = \PYGZob{}\PYGZsq{}a\PYGZsq{}: 1.0, \PYGZsq{}b\PYGZsq{}: 6, \PYGZsq{}c\PYGZsq{}: \PYGZob{}\PYGZsq{}c1\PYGZsq{}: 1, \PYGZsq{}c2\PYGZsq{}: True\PYGZcb{}\PYGZcb{}
a 1.0
b 6
c \PYGZob{}\PYGZsq{}c1\PYGZsq{}: 1, \PYGZsq{}c2\PYGZsq{}: True\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{while loop}
\label{\detokenize{ch/programming/flow_control:while-loop}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} while loop example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{k}{while} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}\PYGZgt{} in while loop, a: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{after while loop, a: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} in while loop, a: 4
\PYGZgt{}\PYGZgt{} in while loop, a: 5
after while loop, a: 5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{altri cicli}
\label{\detokenize{ch/programming/flow_control:altri-cicli}}
\sphinxAtStartPar
\sphinxstylestrong{todo}

\sphinxstepscope


\chapter{Funzioni}
\label{\detokenize{ch/programming/functions:funzioni}}\label{\detokenize{ch/programming/functions::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a function to tell if a number is positive or not}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function returning True if x\PYGZgt{}0, False if x\PYGZlt{}=0 \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} User input to test the function: tuple of numbers}
\PYG{n}{n\PYGZus{}tuple} \PYG{o}{=} \PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{.003}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.4} \PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Test function on all the elements in the user\PYGZhy{}defined tuple}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{n\PYGZus{}tuple}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:} 
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{not }\PYG{l+s+s1}{\PYGZsq{}}
        
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{string}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{positive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1 is not positive
2.0 is positive
0.003 is positive
0.3333333333333333 is positive
\PYGZhy{}2.2 is not positive
0 is not positive
\PYGZhy{}7.4 is not positive
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Default value of function arguments}
\label{\detokenize{ch/programming/functions:default-value-of-function-arguments}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a user function to tell is the first argument is greater than the second.}
\PYG{c+c1}{\PYGZsh{} If no second argument is given, it\PYGZsq{}s set = 0 (default value, defined in the function)}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than  0 ? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{,    ):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Is \PYGZhy{}2 greater than \PYGZhy{}3? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2, \PYGZhy{}3):True
Is \PYGZhy{}2 greater than  0 ? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2,    ):False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Classi}
\label{\detokenize{ch/programming/oo:classi}}\label{\detokenize{ch/programming/oo::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
classi, metodi, oggetti

\item {} 
\sphinxAtStartPar
ereditarietà, overloading

\end{itemize}

\sphinxstepscope


\chapter{Librerie}
\label{\detokenize{ch/programming/libraries:librerie}}\label{\detokenize{ch/programming/libraries::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Definizione del concetto

\item {} 
\sphinxAtStartPar
librerie «standard», scritte da qualcun’altro

\item {} 
\sphinxAtStartPar
scrivere una libreria

\end{itemize}

\sphinxstepscope


\part{Introduzione al calcolo scientifico}

\sphinxstepscope


\chapter{Introduzione al calcolo scientifico}
\label{\detokenize{ch/numerics:introduzione-al-calcolo-scientifico}}\label{\detokenize{ch/numerics:book-numerics-hs}}\label{\detokenize{ch/numerics::doc}}
\sphinxAtStartPar
In questa introduzione al calcolo numerico, vengono presentati alcuni algoritmi. Dove sensato, viene implementata la versione elementare di alcuni di questi algoritmi. Per usi non didattici, e quando possibile, si raccomanda l’uso di algoritmi implementati in librerie disponibili, per questioni di tempo ed efficienza: è lavoro già fatto, da persone che lo sanno fare meglio di noi, controllato, migliorato nel corso degli anni, ottimizzato per ogni sistema e spesso in linguaggi di programmazione diversi da Python, come C o Fortran.

\sphinxAtStartPar
In questa introduzione viene fatto affidamento e uso di alcune librerie disponibili per Python:
\begin{itemize}
\item {} 
\sphinxAtStartPar
librerie con algoritmi e strumenti matematici per il calcolo numerico: \sphinxhref{https://numpy.org}{NumPy}, \sphinxhref{https://scipy.org}{SciPy},…

\item {} 
\sphinxAtStartPar
librerie per la creazione di grafici: \sphinxhref{https://matplotlib.org}{Matplotlib}, \sphinxhref{https://plotly.com}{Plotly},…

\item {} 
\sphinxAtStartPar
librerie per l’analisi dati e la statistica: \sphinxhref{https::/pandas.pydata.org}{pandas},…

\item {} 
\sphinxAtStartPar
librerie per il machine learning: \sphinxhref{https://scikit-learn.org}{sci\sphinxhyphen{}kit}, \sphinxhref{https://pytorch.org}{PyTorch},…

\item {} 
\sphinxAtStartPar
…

\end{itemize}
\subsubsection*{Introduzione al calcolo numerico}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Equazioni lineari

\item {} 
\sphinxAtStartPar
Equazioni non lineari

\item {} 
\sphinxAtStartPar
Approssimazione di funzioni

\item {} 
\sphinxAtStartPar
Derivate

\item {} 
\sphinxAtStartPar
Integrali

\item {} 
\sphinxAtStartPar
Equazioni differenziali ordinarie:
\begin{itemize}
\item {} 
\sphinxAtStartPar
problema di Cauchy ai valori iniziali

\item {} 
\sphinxAtStartPar
problema ai valori al contorno

\end{itemize}

\item {} 
\sphinxAtStartPar
Ottimizzazione, vincolata e non

\end{itemize}
\subsubsection*{Metodi per la statistica}
\subsubsection*{Introduzione al machine learning}

\sphinxstepscope


\chapter{Sistemi lineari}
\label{\detokenize{ch/numerics/linear:sistemi-lineari}}\label{\detokenize{ch/numerics/linear::doc}}
\sphinxAtStartPar
La soluzione di sistemi lineari è un problema che compare in molte altre applicazioni di calcolo numerico.



\sphinxAtStartPar
\sphinxstylestrong{Formalismo matriciale.} Con il formalismo matriciale, un sistema di equazioni lineari può essere scritto come
\begin{equation*}
\begin{split}\mathbf{A} \mathbf{x} = \mathbf{b}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Classificazione.} In generale, i sistemi di equazioni lineari possono essere classificati:
\begin{itemize}
\item {} 
\sphinxAtStartPar
in base al numero di incognite \(n_u\) ed equazioni indipendenti \(n_e\): \(n_e = n_u\) sistemi determinati con un’unica soluzione; \(n_e > n_u\) sistemi sovradeterminati: con nessuna soluzione in generale; \(n_e < n_u\) sistemi indeterminati, con infinite soluzioni in generale

\item {} 
\sphinxAtStartPar
in base alla «struttura» del sistema:
\begin{itemize}
\item {} 
\sphinxAtStartPar
diagonale, tridiagonale, …

\end{itemize}

\item {} 
\sphinxAtStartPar
in base al numero di coefficienti non\sphinxhyphen{}nulli della matrice \(\mathbf{A}\): sistemi con matrice \(\mathbf{A}\) piena o \sphinxstylestrong{sparsa}; questa distinzione non è netta, ma il più delle volte risulta chiara dalla particolare applicazione/metodo.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Algoritmi.} Esistono due grandi classi di metodi/algoritmi per la soluzione di sistemi lineari:
\begin{itemize}
\item {} 
\sphinxAtStartPar
i \sphinxstylestrong{metodi diretti}, che si basano su una fattorizzazione della matrice

\item {} 
\sphinxAtStartPar
i \sphinxstylestrong{metodi indiretti}, che si basano sul calcolo di prodotti matrice\sphinxhyphen{}vettore

\end{itemize}


\section{Sistemi lineari quadrati con matrici piene}
\label{\detokenize{ch/numerics/linear:sistemi-lineari-quadrati-con-matrici-piene}}
\sphinxAtStartPar
In questa sezione si discute la soluzione di sistemi lineari quadrati con matrici piene con le funzoni disponibili nella libreria NumPy.


\subsection{Esempio 1. Sistema quadrato determinato}
\label{\detokenize{ch/numerics/linear:esempio-1-sistema-quadrato-determinato}}
\sphinxAtStartPar
Il sistema lineare
\begin{equation*}
\begin{split}\begin{cases}
  x_1 + 2 \, x_2 = 0 \\
  x_1 + x_3 = -1 \\
  x_1 + x_2 + x_3 = 1 \\
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
può essere riscritto con il formalismo matriciale nella forma \(\mathbf{A} \mathbf{x} = \mathbf{b}\),
\begin{equation*}
\begin{split}
\underbrace{\begin{bmatrix} 1 & 2 & 0 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \end{bmatrix}}_{\mathbf{A}}
\underbrace{\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}}_{\mathbf{x}} =
\underbrace{\begin{bmatrix} 0 \\ -1 \\ 1 \end{bmatrix}}_{\mathbf{b}}
\end{split}
\end{equation*}
\sphinxAtStartPar
e risolto grazie alla funzione \(\texttt{solve(A, b)}\) della libreria \(\texttt{numpy.linalg}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with full square non\PYGZhy{}singular matrices}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{         b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sol, x: [\PYGZhy{}4.  2.  3.]
Proof : Ax = [ 0. \PYGZhy{}1.  1.]
         b = [ 0. \PYGZhy{}1.  1.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Esempio 2. Sistemi quadrati non determinati}
\label{\detokenize{ch/numerics/linear:esempio-2-sistemi-quadrati-non-determinati}}
\sphinxAtStartPar
I sistemi lineari
\begin{equation*}
\begin{split}\begin{cases}
  x_1 + 2 \, x_2 = 1 \\
  x_1 + x_3 = -1 \\
  2 x_1 + 2 \, x_2 + x_3 = 1 \\
\end{cases}
\qquad , \qquad
\begin{cases}
  x_1 + 2 \, x_2 = 0 \\
  x_1 + x_3 = -1 \\
  2 x_1 + 2 \, x_2 + x_3 = 1 \\
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
sono due sistemi quadrati non determinati. Il primo sistema non ha soluzioni, mentre il secondo ne ha infinite della forma
\begin{equation*}
\begin{split}(x_1, x_2, x_3) = (-2, 1, 1) + \alpha (2, -1, -2) \ , \quad \alpha \in \mathbb{R} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Dopo aver riscritto i sistemi lineari con il formalismo matriciale, si può provare a risolverli usando la funzione \(\texttt{solve(A, b)}\) della libreria \(\texttt{numpy.linalg}\). In entrambi i casi, la funzione \(\texttt{solve(A,b)}\) resitiuisce un errore, segnalando che la matrice del sistema lineare è singolare, definizione equivalente di sistemi non determinati.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{dare interpretazione geometrica, fare grafico?}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{spiegare motivo?}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Esistono algoritmi che trovano almeno una soluzione nel caso in cui ne esistano infinite?}: discutere gli algoritmi implementati nella funzione \(numpy.linalg.solve()\) e rimandare alla documentazione della libreria; discutere altri algoritmi che rendono possibile trovare una soluzione

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Esistono algoritmi che trovano una soluzione approssimata nel caso in cui non ne esistano?}: \sphinxstylestrong{minimi quadrati}, minimizzano l’errore, dare un’interpretazione geometrica

\end{itemize}

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with full square singular matrices}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} b = np.array([0.,\PYGZhy{}1.,1.])}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{         b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{LinAlgError}\PYG{g+gWhitespace}{                               }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{11}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8} \PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9} \PYG{c+c1}{\PYGZsh{} b = np.array([0.,\PYGZhy{}1.,1.])}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{11} \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{13} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{14} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}

\PYG{n+nn}{File \PYGZlt{}\PYGZus{}\PYGZus{}array\PYGZus{}function\PYGZus{}\PYGZus{} internals\PYGZgt{}:200,} in \PYG{n+ni}{solve}\PYG{n+nt}{(*args, **kwargs)}

\PYG{n+nn}{File \PYGZti{}/.local/lib/python3.8/site\PYGZhy{}packages/numpy/linalg/linalg.py:386,} in \PYG{n+ni}{solve}\PYG{n+nt}{(a, b)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{384} \PYG{n}{signature} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DD\PYGZhy{}\PYGZgt{}D}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{isComplexType}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dd\PYGZhy{}\PYGZgt{}d}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{385} \PYG{n}{extobj} \PYG{o}{=} \PYG{n}{get\PYGZus{}linalg\PYGZus{}error\PYGZus{}extobj}\PYG{p}{(}\PYG{n}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{386} \PYG{n}{r} \PYG{o}{=} \PYG{n}{gufunc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{signature}\PYG{o}{=}\PYG{n}{signature}\PYG{p}{,} \PYG{n}{extobj}\PYG{o}{=}\PYG{n}{extobj}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{388} \PYG{k}{return} \PYG{n}{wrap}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{result\PYGZus{}t}\PYG{p}{,} \PYG{n}{copy}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nn}{File \PYGZti{}/.local/lib/python3.8/site\PYGZhy{}packages/numpy/linalg/linalg.py:89,} in \PYG{n+ni}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{n+nt}{(err, flag)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{88} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{(}\PYG{n}{err}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{89}     \PYG{k}{raise} \PYG{n}{LinAlgError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Singular matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+ne}{LinAlgError}: Singular matrix
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Matrici sparse}
\label{\detokenize{ch/numerics/linear:matrici-sparse}}
\sphinxAtStartPar
Una matrice sparsa ha un elevato numero di elementi nulli. Una matrice sparsa viene definita in maniera efficiente salvando in memoria solo gli elementi non nulli (\sphinxstylestrong{limiti di memoria}); gli algoritmi per le matrici sparse risultano spesso efficienti perché evitano un molte operazioni che darebbero risultati parziali nulli (\sphinxstylestrong{velocità}).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} dire due parole sui formati

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} fare esempio di calcolo del prodotto matrice vettore per matrici sparse

\end{itemize}


\subsection{Esempio 1 \sphinxhyphen{} Matrice di rigidezza di elementi finiti}
\label{\detokenize{ch/numerics/linear:esempio-1-matrice-di-rigidezza-di-elementi-finiti}}
\sphinxAtStartPar
Il sistema lineare
\begin{equation*}
\begin{split}\begin{bmatrix} 2 & -1 & 0 & 0 & 0 \\ -1 & 2 & -1 & 0 & 0 \\ 0 & -1 & 2 & -1 & 0 \\ 0 & 0 & -1 & 2 & -1 \\ 0 & 0 & 0 & -1  & 2 \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} = \begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{bmatrix} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
è descritto da una matrice, \(N=5\), \(N \times N = 25\), che ha \(N+(N-1)+(N-1) = 13\) elementi non nulli. Il rapporto tra il numero di elementi non nulli e il numero di elementi totali è \(\frac{3N-2}{N^2} \sim \frac{3}{N}\). Al crescere della dimensione del problema, la matrice \(\mathbf{A}\) diventa sempre più sparsa e diventa sempre più conveniente definirla come matrice sparsa, ed usare gli algoritmi pensati per questo tipo di matrici.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with square non\PYGZhy{}singular matrices, in sparse format}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}

\PYG{c+c1}{\PYGZsh{} Printout level: the higher the number, the more verbose the script}
\PYG{n}{printout\PYGZus{}level} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{n\PYGZus{}nodes} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{i\PYGZus{}nodes} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Build sparse stiffness matrix, I: row indices, J: col indices, E: matrix elems}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{i\PYGZus{}nodes}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{J} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{i\PYGZus{}nodes}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{*}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}array}\PYG{p}{(}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{p}{(}\PYG{n}{I}\PYG{p}{,}\PYG{n}{J}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{tocsr}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{printout\PYGZus{}level} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{50} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} print matrix in sparse format}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ I: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{I}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ J: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{J}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{E}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ A:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
\PYG{k}{if} \PYG{p}{(} \PYG{n}{printout\PYGZus{}level} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} convert and primt matrix in full format}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ A.todense(): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{o}{.}\PYG{n}{todense}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} RHS}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{spsolve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sol, x: [2.5 4.  4.5 4.  2.5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Equazioni algebriche non lineari}
\label{\detokenize{ch/numerics/nonlinear:equazioni-algebriche-non-lineari}}\label{\detokenize{ch/numerics/nonlinear::doc}}
\sphinxAtStartPar
Questa sezione si occupa della soluzione delle equazioni algebriche non lineari, distinguendo le equazioni non lineari con una sola incognita \(x \in \mathbb{R}\)
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e i sistemi di equazioni non lineari con un numero di incognite pari al numero di equazione,
\begin{equation*}
\begin{split}\mathbf{f}(\mathbf{x}) = \mathbf{0} \ .\end{split}
\end{equation*}

\section{Equazioni non lineari}
\label{\detokenize{ch/numerics/nonlinear:equazioni-non-lineari}}
\sphinxAtStartPar
Vengono presentati i metodi di bisezione e di Newton per la soluzione di un’equazione non lineare,
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e applicati alla soluzione del problema con \(f(x) = e^x + x\), la cui derivata è nota e immediata da calcolare \(f'(x) = e^x + 1\). L’espressione della derivata verrà utilizzata nel metodo di Newton.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Import libaries \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{time}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example. f(x) = e\PYGZca{}x + x}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Function f and its derivative}
\PYG{n}{f}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}
\PYG{n}{df} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Metodo di bisezione}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-bisezione}}
\sphinxAtStartPar
Il metodo di bisezione per la ricerca degli zeri di una funzione continua \(F(x)\) si basa sul teorema dei valori intermedi per le funzioni continue.

\sphinxAtStartPar
Dati due numeri reali \(a\), \(b\) tali che \(f(a) \, f(b) < 0\), allora esiste un punto \(c \in (a,b)\) tale che \(f(c) = 0\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define bisection\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear scalar equations with bisection method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{bisection\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing the bisection method for scalar equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{if} \PYG{p}{(} \PYG{o+ow}{not} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection algorithm can}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t start, f(a)f(b)\PYGZgt{}= 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
        \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fx}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        
            \PYG{k}{if} \PYG{p}{(} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,c]}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{x}
            \PYG{k}{else}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,b]}
                \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}
        
            \PYG{c+c1}{\PYGZsh{} Update solution and residual}
            \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
            \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Update n.iter}
            \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fx}\PYG{p}{)}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use bisection\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Find 2 values so that \PYGZdl{}f(a) f(b) \PYGZlt{} 0\PYGZdl{}}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{0.}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{bisection\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bisection method summary: 
Convergence reached
Sol, x = \PYGZhy{}0.567143440246582
residual     : \PYGZhy{}2.348157265297246e\PYGZhy{}07
n. iterations: 20
elapsed time : 0.0007159709930419922
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Metodo di Newton}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-newton}}
\sphinxAtStartPar
Per trovare la soluzione del problema non lineare
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
il metodo di Newton sfrutta l’espansione in serie troncata al primo grado della funzione \(f(x)\), per scrivere
\begin{equation*}
\begin{split}0 = f(x^n + \Delta x) \approx f(x^n) + f'(x^n) \Delta x \end{split}
\end{equation*}
\sphinxAtStartPar
e ottenere l’incremento della soluzione \(\Delta x\) come soluzione del sistema lineare
\begin{equation*}
\begin{split}f'(x^n) \Delta x = -f(x^n)\end{split}
\end{equation*}
\sphinxAtStartPar
e aggiornare la soluzione \(x^{n+1} = x^{n} + \Delta x\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define newton\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear scalar equations with Newton\PYGZsq{}s method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{newton\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{.0}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing Newton\PYGZsq{}s method for scalar equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}
    
    \PYG{c+c1}{\PYGZsh{} Newton algorithm}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Solve linear approximation step, and update solution}
        \PYG{n}{dx} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{res} \PYG{o}{/} \PYG{n}{df}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dx}
    
        \PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate new residual and n. of iter}
        \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use newton\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} import numpy as np   \PYGZsh{} already imported}

\PYG{c+c1}{\PYGZsh{} Parameters of the Newton method, for stopping criteria}
\PYG{c+c1}{\PYGZsh{} tol = 1e\PYGZhy{}6          \PYGZsh{} tolerance on the residual |f(x)| \PYGZlt{} tol}
\PYG{c+c1}{\PYGZsh{} max\PYGZus{}niter = 10      \PYGZsh{} max n. of iterations      niter \PYGZgt{} max\PYGZus{}niter}
\PYG{n}{x0} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{newton\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Newton\PYGZsq{}s method summary: 
Convergence reached
Sol, x = \PYGZhy{}0.567143285989123
residual     : 6.927808993140161e\PYGZhy{}09
n. iterations: 3
elapsed time : 0.0005438327789306641
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Sistemi di equazioni non lineari}
\label{\detokenize{ch/numerics/nonlinear:sistemi-di-equazioni-non-lineari}}

\subsection{Metodo di Newton}
\label{\detokenize{ch/numerics/nonlinear:id1}}
\sphinxAtStartPar
Il metodo di Newton sfrutta l’espansione lineare della funzione \(\mathbf{f}(\mathbf{x})\) nell’intorno di un valore \(\mathbf{x}\),
\begin{equation*}
\begin{split}\mathbf{0} = \mathbf{f}(\mathbf{x} + \mathbf{h}) \simeq \mathbf{f}(\mathbf{x}) + \mathbf{f}'(\mathbf{x}) \, \mathbf{h}\end{split}
\end{equation*}
\sphinxAtStartPar
per costruire un metodo iterativo composto da due passi a ogni iterazione:
\begin{itemize}
\item {} 
\sphinxAtStartPar
ricerca dell’incremento:
\begin{equation*}
\begin{split}\mathbf{f}'(\mathbf{x}^{n}) \, \mathbf{h}^{(n)} = - \mathbf{f}(\mathbf{x}^{(n)})\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
aggiornamento della soluzione
\begin{equation*}
\begin{split}\mathbf{x}^{(n+1)} = \mathbf{x}^{(n)} + \mathbf{h}^{(n)} \ .\end{split}
\end{equation*}
\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Esempio.} Il metodo di Newton viene applicato al sistema non lineare
\begin{equation*}
\begin{split}\begin{cases}
    x_0   - x_1 = 0 \\
  - x_0^2 + x_1 = -1
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
che può essere scritto con il formalismo matriciale come
\begin{equation*}
\begin{split}\mathbf{0} = \mathbf{f}(\mathbf{x}) = \begin{bmatrix} x_0 - x_1 \\ -x_0^2 + x_1 - 1 \end{bmatrix} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
La derivata della funzione \(\mathbf{f}(\mathbf{x})\), rispetto alla variabile indipendente \(\mathbf{x}\),
\begin{equation*}
\begin{split}\mathbf{f}'(\mathbf{x}) = \begin{bmatrix} 1 & - 1 \\ - 2 x_0 & 1\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
può essere rappresentata come una matrice che ha come elemento alla riga \(i\) e alla colonna \(j\) la derivata della funzione \(f_i(\mathbf{x})\) rispetto alla variabile \(x_j\), \(\left[ \mathbf{f}' \right]_{ij} = \frac{\partial f_i}{\partial x_j}\), così che l’approssimazione al primo ordine dell’incremento della funzione può essere scritto come
\begin{equation*}
\begin{split}\mathbf{f}(\mathbf{x}+\mathbf{h}) - \mathbf{f}(\mathbf{x}) = \mathbf{f}'(\mathbf{x}) \, \mathbf{h} + o(||\mathbf{h}||) \ .\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example. f(x) = np.array([  x[0]    \PYGZhy{} x[1]}
\PYG{l+s+sd}{                           \PYGZhy{}x[0]**2 + x[1] \PYGZhy{} 1 ])}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Function f and its derivative}
\PYG{n}{f}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define newton\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear systems of equations with Newton\PYGZsq{}s method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{newton\PYGZus{}method\PYGZus{}system}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{.0}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing Newton\PYGZsq{}s method for systems of equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}
    
    \PYG{c+c1}{\PYGZsh{} Newton algorithm}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Solve linear approximation step, and update solution}
        \PYG{n}{dx} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{df}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{res}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dx}
    
        \PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate new residual and n. of iter}
        \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use newton\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} import numpy as np   \PYGZsh{} already imported}

\PYG{c+c1}{\PYGZsh{} Parameters of the Newton method, for stopping criteria}
\PYG{c+c1}{\PYGZsh{} tol = 1e\PYGZhy{}6          \PYGZsh{} tolerance on the residual |f(x)| \PYGZlt{} tol}
\PYG{c+c1}{\PYGZsh{} max\PYGZus{}niter = 10      \PYGZsh{} max n. of iterations      niter \PYGZgt{} max\PYGZus{}niter}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{]}\PYG{p}{)}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{newton\PYGZus{}method\PYGZus{}system}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Newton\PYGZsq{}s method summary: 
Convergence reached
Sol, x = [\PYGZhy{}0.61803399 \PYGZhy{}0.61803399]
residual     : [ 0.00000000e+00 \PYGZhy{}2.10942375e\PYGZhy{}13]
n. iterations: 4
elapsed time : 0.0007107257843017578
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} L’algoritmo di Newton trova solo una soluzione del problema. Cercare le altre soluzioni cambiando il tentativo iniziale.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} … altro?

\end{itemize}

\sphinxstepscope


\chapter{Approssimazione di funzioni}
\label{\detokenize{ch/numerics/approximation:approssimazione-di-funzioni}}\label{\detokenize{ch/numerics/approximation::doc}}

\section{Interpolazione}
\label{\detokenize{ch/numerics/approximation:interpolazione}}

\section{Regressione}
\label{\detokenize{ch/numerics/approximation:regressione}}
\sphinxstepscope


\chapter{Derivate di funzioni}
\label{\detokenize{ch/numerics/derivatives:derivate-di-funzioni}}\label{\detokenize{ch/numerics/derivatives::doc}}

\section{Differenze finite}
\label{\detokenize{ch/numerics/derivatives:differenze-finite}}
\sphinxAtStartPar
Il calcolo della derivata di una funzione \(f(x)\) derivabile in un punto \(x_0\) può essere svolto utilizzando l’espansione locale in serie di Taylor di una funzione.


\subsection{Derivata prima}
\label{\detokenize{ch/numerics/derivatives:derivata-prima}}
\sphinxAtStartPar
Usando le espansioni
\begin{equation*}
\begin{split}\begin{aligned}
  f(x + h) & = f(x) + f'(x) \, h + f''(x) \frac{h^2}{2} + f'''(x) \frac{h^3}{3!} + o(h^3) \\
  f(x - h) & = f(x) - f'(x) \, h + f''(x) \frac{h^2}{2} - f'''(x) \frac{h^3}{3!} + o(h^3)
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
si possono ricavare:
\begin{itemize}
\item {} 
\sphinxAtStartPar
gli schemi del \sphinxstylestrong{primo ordine}
\begin{equation*}
\begin{split}\begin{aligned}
    f'(x) & = \frac{f(x+h) - f(x)}{h} + O(h) \\
    f'(x) & = \frac{f(x) - f(x-h)}{h} + O(h) \\
  \end{aligned}\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
lo schema \sphinxstylestrong{centrato del secondo ordine}
\begin{equation*}
\begin{split}f'(x) = \dfrac{f(x+h) - f(x-h)}{2 h} + O(h^2) \end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
lo schema non centrato del secondo ordine:
\begin{equation*}
\begin{split}f'(x) = \frac{-3 \, f(x) + 4 \, f(x+h) - f(x+2h)}{2 \, h} + O(h^2) \ .\end{split}
\end{equation*}\subsubsection*{Dimostrazione}

\sphinxAtStartPar
Usando le espansioni in serie,
\begin{equation*}
\begin{split}\begin{aligned}
  f(x + h) & = f(x) + f'(x) \, h + f''(x) \frac{h^2}{2} + f'''(x) \frac{h^3}{3!} + o(h^3) \\
  f(x + 2h) & = f(x) + f'(x) \, 2 h + 2 f''(x) \, h^2 + f'''(x) \frac{4}{3} h^3 + o(h^3) \\
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
si cerca una coppia di coefficienti della combinazione lineare \(a_1 f(x+h) + a_2 f(x+2h)\) che annullano il termine di secondo grado.

\sphinxAtStartPar
In particolare è facile dimostrare che una di queste scelte è \(\alpha_1 = 4\), \(\alpha_2 = -1\), e la combinazione lineare per questi valori diventa,
\begin{equation*}
\begin{split}4 f(x+h) - f(x+2h) = 3 f(x) + 2 \, h f'(x) + O(h^3) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
A questo punto è semplice isolare \(f'(x)\) per trovare lo schema numerico desiderato,
\begin{equation*}
\begin{split}f'(x) = \frac{-3 \, f(x) + 4 \, f(x+h) - f(x+2h)}{2 \, h} + O(h^2) \ .\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
…

\item {} 
\sphinxAtStartPar
schemi di ordine superiore…

\end{itemize}


\subsection{Derivata seconda}
\label{\detokenize{ch/numerics/derivatives:derivata-seconda}}
\sphinxAtStartPar
Usando le stesse espansioni in serie, si può ottenere uno schema del secondo ordine per la derivata seconda
\begin{equation*}
\begin{split}f''(x) = \frac{f(x+h) - 2 f(x) + f(x-h)}{h^2} + O(h^2)\end{split}
\end{equation*}\subsubsection*{Dimostrazione}

\sphinxAtStartPar
Usando le espansioni in serie
\begin{equation*}
\begin{split}\begin{aligned}
  f(x + h) & = f(x) + f'(x) \, h + f''(x) \frac{h^2}{2} + f'''(x) \frac{h^3}{3!} + f^{iv}(x) \frac{h^4}{4!} + O(h^5) \\ f(x - h) & = f(x) - f'(x) \, h + f''(x) \frac{h^2}{2} - f'''(x) \frac{h^3}{3!} + f^{iv}(x) \frac{h^4}{4!} + O(h^5) \\
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
si può notare che nella somma che compare al numeratore dello schema numerico si annullano sia il termine di primo grado sia il termine di terzo grado,
\begin{equation*}
\begin{split}
 f(x+h) - 2 f(x) + f(x-h) = f''(x) \, h^2 + O(h^4) \ ,
\end{split}
\end{equation*}
\sphinxAtStartPar
e quindi lo schema numerico proposto è del secondo ordine,
\begin{equation*}
\begin{split}f'(x) = \frac{ f(x+h) - 2 f(x) + f(x-h) }{h^2} + O(h^2) \ .\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Numerical schemes for derivatives \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{df\PYGZus{}first\PYGZus{}order\PYGZus{}left}    \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}
\PYG{n}{df\PYGZus{}first\PYGZus{}order\PYGZus{}right}   \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}
\PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}center} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{h} \PYG{p}{)}
\PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}left}   \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{p}{(}  \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{h} \PYG{p}{)}
\PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}right}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{f}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{h}\PYG{p}{:} \PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{h} \PYG{p}{)}

\PYG{n}{df\PYGZus{}fun\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1\PYGZus{}left}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{p}{:} \PYG{n}{df\PYGZus{}first\PYGZus{}order\PYGZus{}left}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1\PYGZus{}right}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{n}{df\PYGZus{}first\PYGZus{}order\PYGZus{}right}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2\PYGZus{}center}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}center}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2\PYGZus{}left}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{p}{:} \PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}left}\PYG{p}{,}
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2\PYGZus{}right}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{n}{df\PYGZus{}second\PYGZus{}order\PYGZus{}right}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Example \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{f} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{x}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{.01}

\PYG{k}{for} \PYG{n}{df\PYGZus{}label}\PYG{p}{,} \PYG{n}{df\PYGZus{}fun} \PYG{o+ow}{in} \PYG{n}{df\PYGZus{}fun\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Scheme: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{df\PYGZus{}label}\PYG{o}{.}\PYG{n}{ljust}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, value: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{df\PYGZus{}fun}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{x}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Scheme: 1\PYGZus{}left    , value: \PYGZhy{}1.4788256893130014
Scheme: 1\PYGZus{}right   , value: \PYGZhy{}1.4641117378933477
Scheme: 2\PYGZus{}center  , value: \PYGZhy{}1.4714687136031745
Scheme: 2\PYGZus{}left    , value: \PYGZhy{}1.4716195509633268
Scheme: 2\PYGZus{}right   , value: \PYGZhy{}1.4716121945026028
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Integrali}
\label{\detokenize{ch/numerics/integrals:integrali}}\label{\detokenize{ch/numerics/integrals::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Import libraries \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Integrazione di Newton\sphinxhyphen{}Cotes}
\label{\detokenize{ch/numerics/integrals:integrazione-di-newton-cotes}}
\sphinxAtStartPar
Valutazioni di integrali definiti di funzioni \(f: [a,b] \in \mathbb{R} \rightarrow \mathbb{R}\), continue sull’intervallo. Si veda l”{\hyperref[\detokenize{ch/numerics/integrals:integrals-examples-continuity}]{\sphinxcrossref{\DUrole{std,std-ref}{esempio}}}} per intuire la necessità della continuità della funzione.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Formula del punto medio

\item {} 
\sphinxAtStartPar
Formula del trapezio

\end{itemize}


\subsection{Metodo di integrazione del punto medio}
\label{\detokenize{ch/numerics/integrals:metodo-di-integrazione-del-punto-medio}}
\sphinxAtStartPar
Il metodo di integrazione del punto medio ricorda la definizione dell’integrale di Riemann (\sphinxstylestrong{todo} aggiungere link). Data la funzione \(f:[a,b] \in \mathbb{R} \rightarrow \mathbb{R}\), e una partizione \(P = \{ a = x_0 < x_1 < \dots < x_n = b \}\) dell’intervallo \([a,b]\), l’integrale viene calcolato come la somma dell’area dei rettangoli elementari di lati \(\Delta x_k := x_k - x_{k-1}\) e \(f(\xi_k)\), con \(\xi_k \in [x_{k-1}, x_k]\),
\begin{equation*}
\begin{split}\int_{x=a}^{b} f(x) dx \simeq \sum_{k=1:n} f(\xi_k) \, \Delta x_k \ . \end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Mid\PYGZhy{}point method \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{integral\PYGZus{}rect}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Inputs:}
\PYG{l+s+sd}{    \PYGZhy{} f: function}
\PYG{l+s+sd}{    \PYGZhy{} a, b: extreme points of the range}
\PYG{l+s+sd}{    \PYGZhy{} n: n. of intervals of the range}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Partition of the range [a,b]}
    \PYG{c+c1}{\PYGZsh{} uniform partition here; refined algorithms may use non\PYGZhy{}uniform partitions}
    \PYG{n}{xv} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{(} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{n}\PYG{p}{;}  \PYG{n}{xv}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{b}
    \PYG{n}{xc} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(} \PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{n}{xv}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{)}
    \PYG{n}{dx} \PYG{o}{=} \PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xv}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(} \PYG{n}{dx} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xc}\PYG{p}{)} \PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Metodo di integrazione del trapezio}
\label{\detokenize{ch/numerics/integrals:metodo-di-integrazione-del-trapezio}}
\sphinxAtStartPar
Data la funzione \(f:[a,b] \in \mathbb{R} \rightarrow \mathbb{R}\), e una partizione \(P = \{ a = x_0 < x_1 < \dots < x_n = b \}\) dell’intervallo \([a,b]\), l’integrale viene calcolato come la somma dell’area dei trapezi rettangoli elementari con basi \(f(x_{k-1})\), \(f(x_k)\) e altezza \(\Delta x_k := x_k - x_{k-1}\),
\begin{equation*}
\begin{split}\int_{x=a}^{b} f(x) dx \simeq \sum_{k=1:n} \frac{1}{2} \left( f(x_{k-1}) + f(x_k) \right) \, \Delta x_k \ . \end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Trapezoid method \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{integral\PYGZus{}trapz}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Inputs:}
\PYG{l+s+sd}{    \PYGZhy{} f: function}
\PYG{l+s+sd}{    \PYGZhy{} a, b: extreme points of the range}
\PYG{l+s+sd}{    \PYGZhy{} n: n. of intervals of the range}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Partition of the range [a,b]}
    \PYG{c+c1}{\PYGZsh{} uniform partition here; refined algorithms may use non\PYGZhy{}uniform partitions}
    \PYG{n}{xv} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{(} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{n}\PYG{p}{;}  \PYG{n}{xv}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{b}
    \PYG{n}{dx} \PYG{o}{=} \PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xv}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{n}{dx} \PYG{o}{*} \PYG{p}{(} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xv}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Esempi}
\label{\detokenize{ch/numerics/integrals:esempi}}

\subsubsection{Esempio 1.}
\label{\detokenize{ch/numerics/integrals:esempio-1}}
\sphinxAtStartPar
Si valuta l’integrale
\begin{equation*}
\begin{split}\int_{x = 0}^{1} x^2 \, dx = \frac{1}{3} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
con i metodi del punto medio e del trapezio. La funzione \(f(x) = x^2\) è continua ovunque e quindi è continua nell’intervallo \([0,1]\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}

\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}
\PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{10}

\PYG{c+c1}{\PYGZsh{} Evaluate integral with the rect and trapz methods}
\PYG{n}{val\PYGZus{}rect}  \PYG{o}{=} \PYG{n}{integral\PYGZus{}rect}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}
\PYG{n}{val\PYGZus{}trapz} \PYG{o}{=} \PYG{n}{integral\PYGZus{}trapz}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Value of the integral, x }\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{in [}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{] with }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ intervals}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{} mid\PYGZhy{}point method: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val\PYGZus{}rect}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{} trapezoid method: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val\PYGZus{}trapz}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Value of the integral, x \PYGZbs{}in [0.0, 1.0] with 10 intervals
\PYGZhy{} mid\PYGZhy{}point method: 0.3325
\PYGZhy{} trapezoid method: 0.33499999999999996
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Esempio 2. Necessità della continuità della funzione.}
\label{\detokenize{ch/numerics/integrals:esempio-2-necessita-della-continuita-della-funzione}}\label{\detokenize{ch/numerics/integrals:integrals-examples-continuity}}



\section{Integrazione di Gauss}
\label{\detokenize{ch/numerics/integrals:integrazione-di-gauss}}
\sphinxAtStartPar
L’integrazione di Gauss permette di calcolare in \sphinxstylestrong{maniera esatta} l’integrale di una \sphinxstylestrong{funzione polinomiale} \(p_n(x)\) su un intervallo \([a,b]\), come somma pesata della funzione valuatata in alcuni punti dell’intervallo,
\begin{equation*}
\begin{split}\int_a^b p^{(n)}(x) dx = \sum_{g} w_g f(x_g) \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
per un numero di nodi di Gauss, \(n_{Gauss}\) che soddisfa la relazione
\begin{equation*}
\begin{split}n < 2 n_{Gauss} - 1 \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Per motivi di generalizzazione dell’algoritmo, nella definizione dei \sphinxstylestrong{pesi} \(w_i\) e dei \sphinxstylestrong{nodi di Gauss} \(x_i\), l’integrale viene riportato all’integrale su un intervallo di riferimento, tramite una trasformazione di coordinate.
Per domini 1D, l’intervallo di riferimento per la quadratura di Gauss è l’intervallo \(\xi = [-1, 1]\) e il cambio di variabili è
\begin{equation*}
\begin{split}x = \frac{a+b}{2} + \frac{b-a}{2} \, \xi \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
così che l’integrale originale può essere scritto come
\begin{equation*}
\begin{split}\begin{aligned}
\int_{x=a}^b p^{(n)}(x) dx & = \int_{\xi = -1}^{1} p^(n) (x(\xi)) \dfrac{d x}{d\xi} d \xi = \\
 & = \dfrac{b-a}{2} \int_{\xi=-1}^{1} p^{(n)}(x(\xi)) d \xi = \dfrac{b-a}{2} \sum_{g} w_g \, p^{(n)}\left(x(\xi_g)\right)
\end{aligned}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Gauss integration \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Dict of Gauss weights and nodes on the reference interval [\PYGZhy{}1,1] for 1D integration}
\PYG{n}{gauss\PYGZus{}nw} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nodes}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{p}{:} \PYG{p}{[} \PYG{l+m+mf}{0.} \PYG{p}{]}\PYG{p}{,}
                 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+m+mf}{2.} \PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} 
             \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nodes}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{p}{:} \PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{)} \PYG{p}{]}\PYG{p}{,} 
                 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
             \PYG{l+m+mi}{3}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nodes}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{p}{:} \PYG{p}{[} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{)} \PYG{p}{]}\PYG{p}{,} 
                 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+m+mf}{8.}\PYG{o}{/}\PYG{l+m+mf}{9.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{9.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{9.} \PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}int\PYGZus{}1}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{n}\PYG{p}{,} \PYG{n}{a}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{gauss\PYGZus{}nw}\PYG{o}{=}\PYG{n}{gauss\PYGZus{}nw}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} }
\PYG{l+s+sd}{    Integral of the function f(x) }
\PYG{l+s+sd}{    over a physical domain, x \PYGZbs{}in [a, b], }
\PYG{l+s+sd}{    using n number of Gauss nodes}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Cap n.nodes to the max n.nodes stored in gauss\PYGZus{}nw dict}
    \PYG{n}{n} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{[}\PYG{n}{n}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{gauss\PYGZus{}nw}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Gauss nodes (from reference to actual domain) and weights}
    \PYG{n}{xg} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{+} \PYG{p}{(} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{gauss\PYGZus{}nw}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nodes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} \PYG{p}{)}
    \PYG{n}{wg} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{gauss\PYGZus{}nw}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weights}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    
    \PYG{k}{return} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(} \PYG{n}{wg} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{xg}\PYG{p}{)} \PYG{p}{)} 


\PYG{k}{def} \PYG{n+nf}{gauss\PYGZus{}int\PYGZus{}n}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{n\PYGZus{}gauss}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{n\PYGZus{}elems}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} }
\PYG{l+s+sd}{    Integral of the function f(x) }
\PYG{l+s+sd}{    over a physical domain, x \PYGZbs{}in [a, b], (uniformly) splitted in n\PYGZus{}elems}
\PYG{l+s+sd}{    using n number of Gauss nodes per each elem}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} Partition of the interval [a,b]}
    \PYG{n}{xv} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{p}{(} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{a} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n\PYGZus{}elems}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{/} \PYG{n}{n\PYGZus{}elems}\PYG{p}{;}  \PYG{n}{xv}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{b}

    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{[} \PYG{n}{gauss\PYGZus{}int\PYGZus{}1}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{n\PYGZus{}gauss}\PYG{p}{,} \PYG{n}{xv}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{xv}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n\PYGZus{}elems}\PYG{p}{)} \PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Esempio 1 \sphinxhyphen{} integrazione di Gauss.}
\label{\detokenize{ch/numerics/integrals:esempio-1-integrazione-di-gauss}}
\sphinxAtStartPar
Si valuta l’integrale
\begin{equation*}
\begin{split}\int_{x = 0}^{1} x^2 \, dx = \frac{1}{3} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
con il metodo di integrazione di Gauss.
Si chiede di:
\begin{itemize}
\item {} 
\sphinxAtStartPar
osservare che l’integrazione è esatta, a meno degli arrotondamenti dovuti all’aritmetica finita,
poiché la funzione integranda è di grado 2, e il numero di nodi di Gauss è \(n_{Gauss} = 3\); questo è vero indipendentemente dal numero di sotto\sphinxhyphen{}intervalli;

\item {} 
\sphinxAtStartPar
cambiare le funzioni e il numero di nodi usati nelle funzioni per l’integrazione di Gauss per verificare che l’integrazione è esatta per funzioni polinomiali di grado \(2 n_{Gauss} - 1\).

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Evaluate integrals using Gauss integration \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{f} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}

\PYG{c+c1}{\PYGZsh{} Gauss nodes, and n.of elements}
\PYG{n}{n\PYGZus{}gauss} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{n\PYGZus{}elems} \PYG{o}{=} \PYG{l+m+mi}{10}

\PYG{n}{val\PYGZus{}1} \PYG{o}{=} \PYG{n}{gauss\PYGZus{}int\PYGZus{}1}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{n\PYGZus{}gauss}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}
\PYG{n}{val\PYGZus{}n} \PYG{o}{=} \PYG{n}{gauss\PYGZus{}int\PYGZus{}n}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{n\PYGZus{}gauss}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{n\PYGZus{}elems}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Value of the integral, x }\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{in [}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{] using Gauss integration methods with }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}gauss}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ nodes per elem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{} using one elem: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val\PYGZus{}1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{} using }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}elems}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ elems: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val\PYGZus{}n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Value of the integral, x \PYGZbs{}in [0.0, 1.0] using Gauss integration methods with 3 nodes per elem
\PYGZhy{} using one elem: 0.33333333333333337
\PYGZhy{} using 10 elems: 0.33333333333333337
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Equazioni differenziali ordinarie}
\label{\detokenize{ch/numerics/ode:equazioni-differenziali-ordinarie}}\label{\detokenize{ch/numerics/ode::doc}}
\sphinxstepscope


\section{Problemi di Cauchy ai valori iniziali}
\label{\detokenize{ch/numerics/ode-cauchy:problemi-di-cauchy-ai-valori-iniziali}}\label{\detokenize{ch/numerics/ode-cauchy::doc}}

\subsection{Approccio a un problema di Cauchy di ordine \protect\(n\protect\)}
\label{\detokenize{ch/numerics/ode-cauchy:approccio-a-un-problema-di-cauchy-di-ordine-n}}
\sphinxAtStartPar
Un problema di Cauchy di ordine \(n\)
\begin{equation*}
\begin{split}\begin{cases}
  F(y^{(n)}(x), y^{(n-1)}(x), \dots, y'(x), y(x), x) = 0 \\
  y(x_0) = y^0 \\
  y'(x_0) = y'^0 \\
  \dots \\
  y^{(n-1)}(x_0) = y^{(n-1),0}
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
con funzione incognita \(y(x): D \in \mathbb{R} \rightarrow \mathbb{R}\), può essere riscritto come un problema di \sphinxstyleemphasis{«ordine 1»} per la funzione incognita \(\mathbf{z}(x): D \in \mathbb{R} \rightarrow \mathbb{R}^n\), definita come
\begin{equation*}
\begin{split}\mathbf{z}(x) = (z_0(x), z_1(x), \dots z_{n-1}(x)) := (y(x), y'(x), \dots, y^{(n-1)}(x)) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Esplicitando le relazioni tra le componenti di \(\mathbf{z}(x)\) e le derivate della funzione \(y(x)\), \(z_{k}(x) = y^{(k)}(x) = {y^{(k-1)}}'(x) = z'_{k-1}(x)\), il problema di Cauchy può essere riformulato come
\begin{equation*}
\begin{split}\begin{cases}
z'_0 - z_1 = 0 \\
z'_1 - z_2 = 0 \\
\dots \\
z'_{n-2} - z_{n-1} = 0 \\
F(z'_{n-1}(x), z_{n-1}(x), \dots, z_1(x), z_0(x)) = 0 \ ,
\end{cases}
\qquad , \qquad
\text{i.c.} \quad
\begin{cases}
z_0(x_0) = y^0 \\
z_1(x_0) = y'^0 \\
\dots \\
z_{n-1}(x_0) = y^{(n-1),0}
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
che può essere riscritto con il formalismo vettoriale come
\begin{equation*}
\begin{split}\begin{cases}
  \mathbf{F}(\mathbf{z}'(x), \mathbf{z}) = \mathbf{0} \\
  \mathbf{z}(x_0) = \mathbf{z}_0
\end{cases}\end{split}
\end{equation*}

\subsection{Caratteristiche (cenni)}
\label{\detokenize{ch/numerics/ode-cauchy:caratteristiche-cenni}}\begin{itemize}
\item {} 
\sphinxAtStartPar
accuratezza, consistenza, convergenza

\item {} 
\sphinxAtStartPar
stabilità: 0\sphinxhyphen{}, A\sphinxhyphen{} condizionata e incondizionata

\end{itemize}


\subsection{Schemi numerici}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici}}

\subsubsection{Schemi numerici a un passo}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-a-un-passo}}

\subsubsection{Schemi numerici multi\sphinxhyphen{}step}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-multi-step}}
\sphinxstepscope


\section{Problemi al contorno}
\label{\detokenize{ch/numerics/ode-boundary:problemi-al-contorno}}\label{\detokenize{ch/numerics/ode-boundary::doc}}

\subsection{Differenze finite}
\label{\detokenize{ch/numerics/ode-boundary:differenze-finite}}

\subsection{Elementi finiti}
\label{\detokenize{ch/numerics/ode-boundary:elementi-finiti}}

\subsection{Volumi finiti}
\label{\detokenize{ch/numerics/ode-boundary:volumi-finiti}}
\sphinxstepscope


\chapter{Ottimizzazione}
\label{\detokenize{ch/numerics/optimization:ottimizzazione}}\label{\detokenize{ch/numerics/optimization::doc}}
\sphinxAtStartPar
Le tecniche di ottimizzazione sono alla base di molti metodi di interesse, dall’approssimazione di funzioni, alla regolazione e controllo, agli algoritmi usati in intelligenza artificiale

\sphinxstepscope


\part{Statistica}

\sphinxstepscope


\chapter{Metodi per la statistica}
\label{\detokenize{ch/statistics:metodi-per-la-statistica}}\label{\detokenize{ch/statistics:book-statistics-hs}}\label{\detokenize{ch/statistics::doc}}
\sphinxAtStartPar
La statistica si occupa dello studio dei fenomeni in condizioni di incertezza o di non determinismo, determinate da una conoscenza incompleta del modello.

\sphinxAtStartPar
I contenuti seguono l’ordine logico di un approccio alla statistica: dopo aver introdotto la statistica descrittiva e la rappresnetazione dei dati, vengono fornite delle basi di teoria della probabilità necessarie alla deduzione e alle conclusioni tipiche di un’analisi statistica inferenziale.



\sphinxAtStartPar
La statistica è applicabile in \sphinxstylestrong{diversi (tutti?) gli ambiti}: dalla scienze naturali, alle scienze sociali,…
Secondo uno studio, i 12 metodi statistici (cos’è un metodo statistico?) più usati sono: ANOVA, \(\chi^2\)\sphinxhyphen{}test, \(t\)\sphinxhyphen{}test, regressione lineare, coefficiente di correlazione di Pearson, Mann\sphinxhyphen{}Whitney U\sphinxhyphen{}test, Kruskal\sphinxhyphen{}Wallis test, Shannon’s diversity index, Turkey’s range test, cluster analysis, Spearman’s rank correlation coefficient, and PCA.

\sphinxAtStartPar
La statistica è uno strumento fondamentale del \sphinxstylestrong{metodo scientifico}, e si occupa dell’intero processo di:
\begin{itemize}
\item {} 
\sphinxAtStartPar
progetto dell’esperimento

\item {} 
\sphinxAtStartPar
svolgimento esperimento e raccolta dati

\item {} 
\sphinxAtStartPar
analisi dati

\end{itemize}

\sphinxAtStartPar
A seconda dell’uso dei dati raccolti, si riconoscono due approcci alla statistica:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{statistica descrittiva}: riassume i dati raccolti in statistiche riassuntive, senza voler dedurre conclusioni riguardo alla popolazione della quale è stato analizzato il campione; una \sphinxstylestrong{rappresentazione grafica} dei dati e delle statistiche sintetiche risulta molto efficiente per la mente umana

\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{dati di sintesi, non ci sono ipotesi sulle dimensioni di campione e popolazione; una volta disponibili i dati, quelli sono e quelli si riassumono}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{statistica inferenziale}: usa i dati raccolti per dedurre proprietà di una popolazione ampia della quale è stato analizzato un campione ristretto. Le deduzioni si possono spesso riassumere in:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{stima} di distribuzioni di probabilità o valori

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{test di ipotesi}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{uniformare diverse applicazioni allo stesso metodo statistico, ad esempio come diverse interpretazioni che possono essere date allo stesso metodo}
\begin{itemize}
\item {} 
\sphinxAtStartPar
stime: regressione lineare e lineare generalizzata, minimi quadrati,…

\item {} 
\sphinxAtStartPar
…

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{todo} Statistica e ML:
\begin{itemize}
\item {} 
\sphinxAtStartPar
SL: regressione e classificazione

\item {} 
\sphinxAtStartPar
UL: clustering, dimension reduction

\item {} 
\sphinxAtStartPar
ML: otpimization and control

\end{itemize}

\sphinxstepscope


\chapter{Statistica descrittiva}
\label{\detokenize{ch/statistics/descriptive:statistica-descrittiva}}\label{\detokenize{ch/statistics/descriptive:statistics-hs-descriptive}}\label{\detokenize{ch/statistics/descriptive::doc}}
\sphinxAtStartPar
La statistica descrittiva si occupa di descrivere e riassumere le informazioni contenute nei dati disponibili, con lo scopo di:
\begin{itemize}
\item {} 
\sphinxAtStartPar
comunicare il maggior numero di informazioni rilevanti

\item {} 
\sphinxAtStartPar
nella maniera più semplice e sintetica possibile

\end{itemize}

\sphinxAtStartPar
Questo, in accordo con la \sphinxstyleemphasis{percezione umana} \sphinxstylestrong{todo}, avviene tramite indicazioni di:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{posizione}, come la media, la mediana, la moda, o loro variazioni sul tema

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dispersione}, come la deviazione standard, la varianza, lo scarto interquartile,…

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{forma}, come skewness o curtosi, o momenti di ordine superiore

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{correlazione} o \sphinxstylestrong{dipendenza} \sphinxstylestrong{todo} \sphinxstyleemphasis{correlazione non è dipendenza, fare un riferimento; è necessario dedurre una dipendenza? E” tra i compiti della statistica descrittiva?}

\end{itemize}

\sphinxAtStartPar
Oggi sono disponibili librerie e strumenti informatici gratuiti e liberi per l’analisi e la rappresentazione dei dati. Ad esempio, native o compatibili con Python,
\begin{itemize}
\item {} 
\sphinxAtStartPar
pandas, e geoapndas per dati geografici

\item {} 
\sphinxAtStartPar
\sphinxhref{https://plotly.com/graphing-libraries/}{plotly} come libreria grafica (con dash come ambiente per lo sviluppo di semplici app interattive)

\item {} 
\sphinxAtStartPar
…

\end{itemize}

\sphinxAtStartPar
Per una galleria di esempi, si rimanda agli esempi e alle risorse messe a disposizione direttamente dagli sviluppatori, come ad esempio i \sphinxhref{https://plotly.com/python/basic-charts/}{grafici elementari}, o i grafici frequentemente usati in \sphinxhref{https://plotly.com/python/statistical-charts/}{statistica}, e un”\sphinxhref{https://plotly.com/python/fundamentasl/}{introduzione} con le impostazioni di base. Per un livello di dettaglio maggiore, è spesso possibile consultare i file sorgenti con l’implementazione degli strumenti resi disponibili su repository pubblici: nel caso di plotly è possibile consultare questi file nel \sphinxhref{https://github.com/plotly}{repository pubblico}.


\section{Dimensione dei dati}
\label{\detokenize{ch/statistics/descriptive:dimensione-dei-dati}}\begin{itemize}
\item {} 
\sphinxAtStartPar
variabili 1\sphinxhyphen{}dimensionali

\item {} 
\sphinxAtStartPar
variabili 2\sphinxhyphen{}dimensionali o di dimenione piccola

\item {} 
\sphinxAtStartPar
variabili di grandi dimensioni: possono essere necessarie tecniche di riduzione dei dati per far emergere le proprietà significative contenute nei dati raccolti

\end{itemize}


\section{Rappresentazione grafica}
\label{\detokenize{ch/statistics/descriptive:rappresentazione-grafica}}
\sphinxAtStartPar
\sphinxstylestrong{EDA: exploratory data analysis.} Può essere utilizzata in applicazioni di statistica descrittiva o nelle prime fasi di applicazioni di statistica inferenziale, «per vedere che faccia hanno i dati raccolti» e per fare una prima selezione dei metodi da applicare nelle fasi successive dell’indagine.

\sphinxAtStartPar
Attualmente, sono disponibili i mezzi informatici e un gran numero di librerie per l’analisi dati, dall’elaborazione alla rappresentazione.


\section{Variabili 1\sphinxhyphen{}dimensionali}
\label{\detokenize{ch/statistics/descriptive:variabili-1-dimensionali}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{express} \PYG{k}{as} \PYG{n+nn}{px}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{iris}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
   sepal\PYGZus{}length  sepal\PYGZus{}width  petal\PYGZus{}length  petal\PYGZus{}width species  species\PYGZus{}id
0           5.1          3.5           1.4          0.2  setosa           1
1           4.9          3.0           1.4          0.2  setosa           1
2           4.7          3.2           1.3          0.2  setosa           1
3           4.6          3.1           1.5          0.2  setosa           1
4           5.0          3.6           1.4          0.2  setosa           1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} !pip install plotly==5.10}
\PYG{c+c1}{\PYGZsh{} !pip install plotly==5.24}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{plotly} \PYG{k}{as} \PYG{n+nn}{p}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{p}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}version\PYGZus{}\PYGZus{}}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{io} \PYG{k}{as} \PYG{n+nn}{pio}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{express} \PYG{k}{as} \PYG{n+nn}{px}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{offline} \PYG{k}{as} \PYG{n+nn}{py}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{iris}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sepal\PYGZus{}width}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sepal\PYGZus{}length}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{species}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sepal\PYGZus{}length}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
5.24.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Display Plotly chart}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{graph\PYGZus{}objects} \PYG{k}{as} \PYG{n+nn}{go}
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{io} \PYG{k}{as} \PYG{n+nn}{pio}

\PYG{n}{fig} \PYG{o}{=} \PYG{n}{go}\PYG{o}{.}\PYG{n}{Figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}trace}\PYG{p}{(}\PYG{n}{go}\PYG{o}{.}\PYG{n}{Scatter}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y = x\PYGZca{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{\PYGZsh{} Force MathJax to re\PYGZhy{}render}
\PYG{l+s+sd}{from IPython.display import display, Javascript}
\PYG{l+s+sd}{display(Javascript(\PYGZdq{}MathJax.Hub.Queue([\PYGZsq{}Typeset\PYGZsq{}, MathJax.Hub]);\PYGZdq{}))}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZbs{}n\PYGZsh{} Force MathJax to re\PYGZhy{}render\PYGZbs{}nfrom IPython.display import display, Javascript\PYGZbs{}ndisplay(Javascript(\PYGZdq{}MathJax.Hub.Queue([\PYGZbs{}\PYGZsq{}Typeset\PYGZbs{}\PYGZsq{}, MathJax.Hub]);\PYGZdq{}))\PYGZbs{}n\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{plotly}\PYG{n+nn}{.}\PYG{n+nn}{express} \PYG{k}{as} \PYG{n+nn}{px}

\PYG{c+c1}{\PYGZsh{} import plotly.io as pio}
\PYG{c+c1}{\PYGZsh{} pio.renderers.default = \PYGZdq{}iframe\PYGZus{}connected\PYGZdq{}}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{iris}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{px}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sepal\PYGZus{}width}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sepal\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{species}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} all three of these worked}
\PYG{c+c1}{\PYGZsh{} fig.show(renderer=\PYGZsq{}iframe\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{} fig.show(renderer=\PYGZsq{}iframe\PYGZus{}connected\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{} fig.show(renderer=\PYGZsq{}colab\PYGZsq{})}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Variabili 2\sphinxhyphen{}dimensionali}
\label{\detokenize{ch/statistics/descriptive:variabili-2-dimensionali}}\begin{equation*}
\begin{split}a = 1\end{split}
\end{equation*}

\section{Variabili di grandi dimensioni}
\label{\detokenize{ch/statistics/descriptive:variabili-di-grandi-dimensioni}}
\sphinxstepscope

\sphinxAtStartPar
()=


\chapter{Introduzione alla probabilità}
\label{\detokenize{ch/statistics/probability:introduzione-alla-probabilita}}\label{\detokenize{ch/statistics/probability::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Variabili casuali

\item {} 
\sphinxAtStartPar
Processi casuali

\end{itemize}

\sphinxstepscope


\section{Variabili casuali}
\label{\detokenize{ch/statistics/random_variables:variabili-casuali}}\label{\detokenize{ch/statistics/random_variables:statistics-hs-random-variables}}\label{\detokenize{ch/statistics/random_variables::doc}}
\sphinxAtStartPar
Qualitativamente, una variabile casuale è una grandezza che può assumere valori diversi come risultato di un fenomeno aleatorio, un fenomeno che non è possibile descrivere accuratamente con delle equazioni deterministiche. \sphinxstylestrong{todo} \sphinxstyleemphasis{fare esempi: lancio del dado e estrema dipendenza dalle condizioni iniziali, soprattutto con urto; aggiungere simulazione, già presente sul drive}

\sphinxAtStartPar
\sphinxstylestrong{Contenuti.}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Definizione di variabile casuale

\item {} 
\sphinxAtStartPar
Varaibili casuali discrete

\item {} 
\sphinxAtStartPar
Variabili casuali continue

\item {} 
\sphinxAtStartPar
Trasformazione di funzioni di probabilità

\item {} 
\sphinxAtStartPar
Funzioni di probabilità comuni

\item {} 
\sphinxAtStartPar
Variabili casuali indipendenti e identicamente distribuite

\item {} 
\sphinxAtStartPar
Campionamento (\sphinxstylestrong{todo} qui o nella parte di statistica inferenziale, stima?)

\end{enumerate}

\sphinxstepscope


\subsection{Definizione di variabile casuale}
\label{\detokenize{ch/statistics/random_variables_definition:definizione-di-variabile-casuale}}\label{\detokenize{ch/statistics/random_variables_definition:statistics-hs-random-variables-def}}\label{\detokenize{ch/statistics/random_variables_definition::doc}}
\sphinxAtStartPar
Qualitativamente, una variabile casuale è una grandezza che può assumere valori diversi come risultato di un fenomeno aleatorio, un fenomeno che non è possibile descrivere accuratamente con delle equazioni deterministiche. todo fare esempi: lancio del dado e estrema dipendenza dalle condizioni iniziali, soprattutto con urto; aggiungere simulazione, già presente sul drive

\sphinxAtStartPar
Una definizione più rigorosa prevede i concetti di spazio di probabilità e
\sphinxhyphen{}algebra. Senza pretendere di fornire una descrizione dettagliata e rigorosa di questi oggetti matematici, non si vuole rinunciare a dare la definizione rigorosa di variabile casuale, fornendo un’interpretazione degli oggetti matematici coinvolti.


\subsubsection{Definizione}
\label{\detokenize{ch/statistics/random_variables_definition:definizione}}
\sphinxAtStartPar
Dato uno \sphinxstyleemphasis{spazio di probabilità} \((\Omega, \mathcal{F}, \nu)\) e uno \sphinxstyleemphasis{spazio misurabile} \((E, \mathcal{E})\), una \sphinxstylestrong{variabile aleatoria} è una funzione misurabile \(X: \Omega \rightarrow E\).

\sphinxAtStartPar
Ora, cerchiamo di interpretare questa definizione criptica. Iniziamo dalle cose semplici:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\Omega\) ed \(E\) sono due \sphinxstyleemphasis{insiemi}: \(\Omega\) viene definito *insieme degli \sphinxstylestrong{eventi} o \sphinxstyleemphasis{spazio campionario}, \(E\) è l’insieme dei \sphinxstylestrong{valori} che può assumere la variabile casuale.

\end{itemize}

\sphinxAtStartPar
Se l’insieme \(E\) dei possibili valori della variabile casuale è un insieme di elementi discreti, si definisce la variabile casuale \sphinxstylestrong{discreta}.
Se l’insieme \(E\) è invece un insieme di valori continui, come ad esempio un intervallo \(I \subset \mathbb{R}\), la variabile viene definita \sphinxstylestrong{continua}.
Le variabili casuali possono essere \sphinxstylestrong{numeriche} o \sphinxstylestrong{categoriali}: le variabili casuali numeriche hanno valori numerici, quelle categoriali possono essere identificate da etichette: ad esempio, una variabile \(X\) che rappresenta il mezzo preferito di locomozione con valori nell’insieme \(\{ \text{piedi}, \text{bici}, \text{treno}, \text{auto}, \text{altro} \}\) è una variabile categoriale. Le variabili categoriali possono essere o non essere ordinabili; se non sono numeriche, non è possibile compiere operazioni numeriche su di esse.

\sphinxAtStartPar
Continuiamo con gli altri oggetti meno immediati:
\begin{itemize}
\item {} 
\sphinxAtStartPar
lo spazio di probabilità \((\Omega, \mathcal{F}, \nu)\) può essere pensato come formato da due parti, lo spazio misurabile \((\Omega, \mathcal{F})\) e la misura di probabilità \(\nu\);

\item {} 
\sphinxAtStartPar
nella definizione ora sono conivolti due spazi misurabili, \((\Omega, \mathcal{F})\), \((E, \mathcal{E})\), che a loro volta sono composti da due oggetti:
\begin{itemize}
\item {} 
\sphinxAtStartPar
un insieme di elementi;

\item {} 
\sphinxAtStartPar
una \(\sigma\)\sphinxhyphen{}algebra: per quanto interessa a noi, una \(\sigma\)\sphinxhyphen{}algebra applicata agli elementi di un insieme offre la possibiltà di applicare le operazioni degli insiemi (unione, intersezione,…) agli elementi dell’insieme

\end{itemize}

\item {} 
\sphinxAtStartPar
la misura di probabilità \(\nu\) è una funzione compatibile con gli spazi misurabili coinvolti nella definizione, che traduce in matematica i concetti della probabilità come, ad esempio:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(P(\omega \in \Omega) = 1\),

\item {} 
\sphinxAtStartPar
\(P(\omega \in A \lor \omega \in B) \le P(\omega \in A) + P(\omega \in B)\), e l’uguaglianza vale se \(A\), \(B\) disgiunti

\item {} 
\sphinxAtStartPar
…

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Spieghiamoci peggio con due esempi.

\sphinxAtStartPar
\sphinxstylestrong{todo.} L’evento è sempre osservabile? O si può osservare solo il valore assunto dalla variabile casuale?


\paragraph{Esempio 1. Lancio dado non truccato, con variabile casuale corrispondente al valore della faccia}
\label{\detokenize{ch/statistics/random_variables_definition:esempio-1-lancio-dado-non-truccato-con-variabile-casuale-corrispondente-al-valore-della-faccia}}
\sphinxAtStartPar
Viene lanciato un dato a 6 facce non truccato. Questo corrisponde a un insieme degli eventi costituito da i 6 eventi distinti \(\Omega = \{ \text{faccia 1}, \dots, \text{faccia 6} \}\), e ognuno di questi 6 eventi ha una misura di probabilità uguale a \(\nu(\text{faccia 1}) = \dots = \nu(\text{faccia 6}) = \frac{1}{6}\). Si sceglie come variabile casuale la funzione che associa al numero letto sulla faccia lo stesso numero, \(X: \Omega \rightarrow E\), \(X(\text{faccia n}) = n\). Si vogliono ora analizzare le probabilità associate ai seguenti eventi:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\Omega_1\): eventi che portano a risultato 3:
\begin{equation*}
\begin{split}P(X(\omega \in \Omega_1) = 3) = P(\omega \in \Omega_1) = \nu(\text{faccia 3}) = \frac{1}{6}\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
\(\Omega_2\): eventi che portano a risultato pari,
\begin{equation*}
\begin{split}\begin{aligned}
    P(\omega \in \Omega_2) 
    & = P\big(X(\omega \in \Omega_2) = 2 \lor X(\omega \in \Omega_2) = 4 \lor X(\omega \in \Omega_2) = 6\big) = \\
    & = \nu(\text{faccia 2}) + \nu(\text{faccia 4}) + \nu(\text{faccia 6}) = \frac{1}{2}
  \end{aligned}\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
\(\Omega_3\): eventi che portano a risultato dispari

\item {} 
\sphinxAtStartPar
\(\Omega_4\): eventi che portano a risultato inferiore a 4

\item {} 
\sphinxAtStartPar
\(\Omega_5\): eventi che portano a un risultato compreso tra 1 e 6 inclusi

\item {} 
\sphinxAtStartPar
\(\Omega_6\): eventi che verificano gli eventi \(\Omega_2\) \sphinxstylestrong{o} gli eventi \(\Omega_4\)

\item {} 
\sphinxAtStartPar
\(\Omega_7\): eventi che verificano gli eventi \(\Omega_2\) \sphinxstylestrong{e} gli eventi \(\Omega_4\)

\end{itemize}


\paragraph{Esempio 2. Lancio dado non truccato, con variabile casuale diverso dal valore della faccia}
\label{\detokenize{ch/statistics/random_variables_definition:esempio-2-lancio-dado-non-truccato-con-variabile-casuale-diverso-dal-valore-della-faccia}}
\sphinxAtStartPar
Si studino ora i casi in cui la variabile casuale associa all’evento:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
il valore della faccia diviso 2 e aumentato di 1

\item {} 
\sphinxAtStartPar
il massimo divisore diverso del numero sulla faccia, diverso dal numero stesso

\end{enumerate}

\sphinxstepscope


\subsection{Variabili casuali discrete}
\label{\detokenize{ch/statistics/random_variables_discrete:variabili-casuali-discrete}}\label{\detokenize{ch/statistics/random_variables_discrete:statistics-hs-random-variables-discrete}}\label{\detokenize{ch/statistics/random_variables_discrete::doc}}

\subsubsection{Funzione di probabilità}
\label{\detokenize{ch/statistics/random_variables_discrete:funzione-di-probabilita}}
\sphinxAtStartPar
La funzione di probabilità, \(p_X(x)\), o funzione di massa, o \sphinxstyleemphasis{densità di probabilità} con un abuso per analogia con le variabili continue, è la funzione che associa la probabilità al valore \(x\) della variabile casuale \(X\). Data al variabile casuale \(X: \Omega \rightarrow E\), la proababilità del valore discreto \(x \in E\) è data dalla somma delle probabilità degli eventi disgiunti \(\Omega_x := \{ \omega \in \Omega \, | \, X(\omega) = x \}\) che producono il valore \(x\),
\begin{equation*}
\begin{split}p_X(x) = \sum_{\omega_i \in \Omega_x} \nu(\omega_i) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Proprietà.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p_X \ge 0\)

\item {} 
\sphinxAtStartPar
\(\sum_{x_k \in E} p_X(x_k) = 1\)

\end{itemize}

\sphinxAtStartPar
E da queste due proprietà segue che la probabilità del singolo valore è non superiore a 1, \(p(x_k) \le 1\).


\subsubsection{Esempi di variabili discrete}
\label{\detokenize{ch/statistics/random_variables_discrete:esempi-di-variabili-discrete}}
\sphinxAtStartPar
Si anticipano qui alcuni {\hyperref[\detokenize{ch/statistics::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{esempi di variabili casuali discrete}}}}, rapprestandone la loro distribuzione di probabilità: la distribuzione di Bernoulli, la distribuzione binomiale, e la distribuzione di Poisson. La distribuzione di \sphinxstylestrong{Bernoulli} può rappresentare la probabilità che il lancio di una moneta dia testa:\(0\) o croce:\(1\), la distribuzione \sphinxstylestrong{binomiale} può rappresentare la probabilità di ottenere \(x\) volte croce in \(n\) lanci; la distribuzione di \sphinxstylestrong{Poisson} viene usata per rappresentare eventi discreti rari, dei quali si conosce la media \(\lambda\).

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{136305ea5229770747aff0206d802d1741ac2f86b63e9a3f3e88b2377b482e71}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\begin{sphinxuseclass}{tag_hide-output}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Momenti}
\label{\detokenize{ch/statistics/random_variables_discrete:momenti}}
\sphinxAtStartPar
\sphinxstylestrong{Valore medio.} Il valore medio di una variabile casuale è la media dei valori possibili \(x_k \in E\) pesata della probabilità \(p(x_k)\),
\begin{equation*}
\begin{split}\begin{aligned}
 \mu_X = \text{E}[X] 
  & := \sum_{x_k \in E} p(x_k) x_k = \\
  & = \sum_{x_k \in E} \sum_{\omega_i \in \Omega_x} \nu(\omega_i) X(\omega_i) = \\
  & = \sum_{\omega_i \in \Omega} \nu(\omega_i) X(\omega_i) \ .
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
equivalente alla media dei valori della variabile \(X(\omega_i)\) pesata sulle probabilità degli eventi \(\omega_i \in \Omega\). La media di una varaibile casuale \(X\) viene comunemente indicata con \(\mu_X\), e così verrà fatto in seguito per motivi di sintesi.

\sphinxAtStartPar
\sphinxstylestrong{Varianza.} La varianza è una misura della dispersione dei valori di una varaibile casuale attorno al suo valore medio, ed è definita come la media pesata degli scarti quadratici,
\begin{equation*}
\begin{split}\sigma^2_X = E[(X-\mu_X)^2] = \sum_k p(x_k) (x_k - \mu_X)^2 \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Analogamente a quanto fatto per il valore medio, anche questa media può essere riferita sia ai valori sia agli eventi.

\sphinxAtStartPar
La \sphinxstylestrong{variazione standard} è definita come la radice quadra della varianza. A differenza della varianza, è una grandezza \sphinxstyleemphasis{omogenea} \sphinxstylestrong{(!)} alla variabile casuale: ad esempio, la media di una misura di lunghezza può essere \(2 \, m\) con deviazione standard \(0.1 \, m\), mentre la varianza è \(0.01 \, m^2\).

\sphinxAtStartPar
Di seguito vengono mostrati il valore medio e la deviazione standard \sphinxhyphen{} rappresentata qui come un intervallo centrato attorno alla media, anche se questa rappresentazione può essere ingannevole \sphinxstylestrong{(!)} per distribuzioni di probabilità non simmetriche \sphinxhyphen{} delle variabili casuali presentate in precedenza. In seguito, verrà introdotto il concetto di \sphinxstyleemphasis{intervallo di confidenza}. \sphinxstylestrong{todo} \sphinxstyleemphasis{riferimento?}

\sphinxAtStartPar
\sphinxstylestrong{Oss.} Nonostante siano rappresentati in tutto il grafico, si deve pensare alla media come un valore sull’asse \(x\) dei valori della variabile casuale, e la deviazione standard come un intervallo sullo stesso asse \(x\), ricordando le osservazioni fatte in precedenza sulla rappresentazione della deviazione standard.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{f7ed6c19b2a60b6d9381613feced82dc7fa26d4847689119ed6079dbd6baded8}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}



\subsubsection{Variabili casuali multi\sphinxhyphen{}dimensionali}
\label{\detokenize{ch/statistics/random_variables_discrete:variabili-casuali-multi-dimensionali}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Probabilità congiunta.} \(p(x,y)\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Probabilità condizionale.} \(p(x|y)\)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Probabilità marginale.} \(p(x)\)

\end{itemize}


\paragraph{Probabilità congiunta e teorema di Bayes}
\label{\detokenize{ch/statistics/random_variables_discrete:probabilita-congiunta-e-teorema-di-bayes}}\begin{equation*}
\begin{split}p(x,y) = p(x|y)p(y) = p(y|x)p(x)\end{split}
\end{equation*}

\paragraph{Variabili indipendenti}
\label{\detokenize{ch/statistics/random_variables_discrete:variabili-indipendenti}}
\sphinxAtStartPar
Due variabili casuali sono indipendenti se la probabilità condizionale di una variabile coincide con la sua probabilità marginale,
\begin{equation*}
\begin{split}p(x|y) = p(x) \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
così che la probabilità congiunta di due variabili casuali indipendenti è il prodotto delle probabilità marginali,
\begin{equation*}
\begin{split}p(x,y) = p(x)p(y) \ .\end{split}
\end{equation*}

\paragraph{Covarianza}
\label{\detokenize{ch/statistics/random_variables_discrete:covarianza}}\begin{equation*}
\begin{split}\sigma^2_{ij} = E[(X_i-\mu_i)(X_j-\mu_j)] = R_{ij} - \mu_i \mu_j\end{split}
\end{equation*}

\paragraph{Correlazione}
\label{\detokenize{ch/statistics/random_variables_discrete:correlazione}}\begin{equation*}
\begin{split}\rho_{XY} = \frac{E[(X-\mu_X)(Y-\mu_Y)]}{E[(X-\mu_X)^2]^{1/2} \, E[(X-\mu_X)^2]^{1/2}} = \frac{\sigma_{XY}^2}{\sigma_X \, \sigma_Y}\end{split}
\end{equation*}
\sphinxstepscope


\subsection{Variabili casuali continue}
\label{\detokenize{ch/statistics/random_variables_continuous:variabili-casuali-continue}}\label{\detokenize{ch/statistics/random_variables_continuous:statistics-hs-random-variables-continuous}}\label{\detokenize{ch/statistics/random_variables_continuous::doc}}
\sphinxstepscope


\subsection{Trasformazione di probabilità di densità}
\label{\detokenize{ch/statistics/rv_pdf_transformations:trasformazione-di-probabilita-di-densita}}\label{\detokenize{ch/statistics/rv_pdf_transformations::doc}}

\subsubsection{Variabile singola}
\label{\detokenize{ch/statistics/rv_pdf_transformations:variabile-singola}}

\paragraph{Cambio di variabile}
\label{\detokenize{ch/statistics/rv_pdf_transformations:cambio-di-variabile}}

\subparagraph{Traslazione}
\label{\detokenize{ch/statistics/rv_pdf_transformations:traslazione}}

\subparagraph{Scalatura}
\label{\detokenize{ch/statistics/rv_pdf_transformations:scalatura}}

\subsubsection{Multi\sphinxhyphen{}variabile}
\label{\detokenize{ch/statistics/rv_pdf_transformations:multi-variabile}}

\paragraph{Combinazione di variabili}
\label{\detokenize{ch/statistics/rv_pdf_transformations:combinazione-di-variabili}}

\subparagraph{Somma}
\label{\detokenize{ch/statistics/rv_pdf_transformations:somma}}
\sphinxAtStartPar
Date due variabili casuali \(X\), \(Y\), con probabilità congiunta \(p_{XY}(x,y)\), la loro somma \(Z = X + Y\) è una variabile casuale dipendente con distribuzione di probabilità
\begin{equation*}
\begin{split}p(z) = \int_y p_{XY}(z-y,y) \, dy = \int_{x} p_{XY}(x, z-x) \, dx \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Se le due variabili sono tra di loro \sphinxstyleemphasis{statisticamente indipendenti}, la densità di probabilità congiunta è uguale al prodotto delle densità di probabilità delle singole variabili, \(p_{XY}(x,y) = p_X(x) p_Y(y)\), e quindi la densità di probabilità della somma è uguale alla \sphinxstylestrong{convoluzione} tra le densità di probabilità delle due variabili,
\begin{equation*}
\begin{split}p(z) = \int_y p_{X}(z-y) \, p_{Y}(y) \, dy \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Il \sphinxstylestrong{valore atteso} della somma è quindi
\begin{equation*}
\begin{split}E[Z] = \int_z z \, p(z) \, dz = \int_{y,z} z \, p_{XY}(z-y,y) \, dy \, dz =  \int_{x,y} (x+y) \, p_{XY}(x,y) \, dx \, dy \ , \end{split}
\end{equation*}
\sphinxAtStartPar
e, nel caso in cui le due variabili siano tra di loro \sphinxstyleemphasis{statisticamente indipendenti},
\begin{equation*}
\begin{split}\begin{aligned}
  E[Z]
  & = \int_{x,y} (x + y) \, p_X(x) \, p_Y(y) \, dx \, dy = \\
  & = \int_{x,y} x \, p_X(x) \, p_Y(y) \, dx \, dy + \int_{x,y} y \, p_X(x) \, p_Y(y) \, dx \, dy = \\
  & = \int_x x \, p_X(x) \, dx + \int_y y \, p_Y(y) \, dy = E[X] + E[Y] \ .
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
La \sphinxstylestrong{varianza} della somma è
\begin{equation*}
\begin{split}\begin{aligned}
  \sigma_Z^2 = E\left[(Z - E[Z])^2\right] 
  = E\left[Z^2\right] - E[Z]^2
  = \int_z z^2 p(z) \, dz - E[Z]^2
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
e nel caso le due variabili siano tra di loro \sphinxstyleemphasis{statisticamente indipendenti},
\begin{equation*}
\begin{split}\begin{aligned}
  \sigma_Z^2 
  & = \int_z z^2 p(z) \, dz - E[Z]^2 = \\
  & = \int_{x,y} (x+y)^2 \, p_{X}(x) \, p_{Y}(y) \, dx \, dy - \left(E[X] + E[Y]\right)^2 = \\
  & = \int_{x} x^2 \, p{X}(x) \, dx + \int_{y} y^2 \, p_Y(y) \, dy + 2 E[X] E[Y] - \left( E[X]^2 + 2 E[X] E[Y] + E[Y]^2 \right) = \\
  & = \int_{x} x^2 \, p{X}(x) \, dx - E[X]^2 + \int_{y} y^2 \, p_Y(y) \, dy - E[Y]^2 = \\
  & = \sigma_X^2 + \sigma_Y^2 \ .
\end{aligned}\end{split}
\end{equation*}

\subparagraph{Prodotto}
\label{\detokenize{ch/statistics/rv_pdf_transformations:prodotto}}
\sphinxAtStartPar
Date due variabili casuali \(X\), \(Y\) con probabilità congiunta \(p_{XY}(x,y)\), il loro prodotto \(Z = X \cdot Y\) è una variabile casuale dipendente con distribuzione di probabilità
\begin{equation*}
\begin{split}p(z) = \int_{y} p_{XY} \left(\frac{z}{y}, y \right) \, dy = \int_{x} p_{XY} \left(x, \frac{z}{x} \right) \, dx\end{split}
\end{equation*}
\sphinxAtStartPar
Se le due variabili sono \sphinxstyleemphasis{statisticamente indipendenti},…\sphinxstylestrong{todo}

\sphinxAtStartPar
Il \sphinxstylestrong{valore atteso} del prodotto è
\begin{equation*}
\begin{split}E[Z] = \int_z z \, p(z) \, dz = \int_{y,z} z \, p_{XY}\left(\frac{z}{y},y\right) \, dy \, dz =  \int_{x,y} x y \, p_{XY}(x,y) \, dx \, dy \ , \end{split}
\end{equation*}
\sphinxAtStartPar
e, nel caso in cui le due variabili siano tra di loro \sphinxstyleemphasis{statisticamente indipendenti},
\begin{equation*}
\begin{split}\begin{aligned}
  E[Z]
  & = \int_{x,y} x y \, p_X(x) \, p_Y(y) \, dx \, dy = \\
  & = \int_{x} x \, p_X(x) \, dx \cdot \int_y y \, p_Y(y) \, dy = E[X] \cdot E[Y] \ .
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
La \sphinxstylestrong{varianza} del prodotto è
\begin{equation*}
\begin{split}\begin{aligned}
  \sigma_Z^2 = ...
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
e nel caso le due variabili siano tra di loro \sphinxstyleemphasis{statisticamente indipendenti},
\begin{equation*}
\begin{split}\begin{aligned}
  \sigma_Z^2 
  & = \int_{x,y} x^2 y^2 p_X(x) \, p_Y(y) \, dx \, dy - \left( E[X] \, E[Y] \right)^2 = \\
  & = R_X^2 \, R_Y^2 - E[X]^2 \, E[Y]^2 = \\
  & = \left( \sigma_X^2 + E[X]^2 \right)\left( \sigma_Y^2 + E[Y]^2 \right) - E[X]^2 \, E[Y]^2 = \\
  & = \sigma_X^2 \, \sigma_Y^2 + \sigma_X^2 \, E[Y]^2 + \sigma_Y^2 \, E[X]^2
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
In termini di correlazione, \(R_X^2 = \sigma_X^2 + E[X]^2\),
\begin{equation*}
\begin{split}R_Z^2 = R_X^2 \, R_Y^2 \ .\end{split}
\end{equation*}
\sphinxstepscope


\subsection{Esempi di funzioni di probabilità discreta}
\label{\detokenize{ch/statistics/pfun_discrete_examples:esempi-di-funzioni-di-probabilita-discreta}}\label{\detokenize{ch/statistics/pfun_discrete_examples::doc}}

\subsubsection{Bernoulli}
\label{\detokenize{ch/statistics/pfun_discrete_examples:bernoulli}}

\subsubsection{Binomiale}
\label{\detokenize{ch/statistics/pfun_discrete_examples:binomiale}}

\subsubsection{Poisson}
\label{\detokenize{ch/statistics/pfun_discrete_examples:poisson}}
\sphinxstepscope


\subsection{Esempi di funzioni di probabilità continua}
\label{\detokenize{ch/statistics/pfun_continuous_examples:esempi-di-funzioni-di-probabilita-continua}}\label{\detokenize{ch/statistics/pfun_continuous_examples::doc}}

\subsubsection{Distribuzione gaussiana o normale, \protect\(\mathscr{N}\protect\)}
\label{\detokenize{ch/statistics/pfun_continuous_examples:distribuzione-gaussiana-o-normale-mathscr-n}}
\sphinxAtStartPar
\(\mathscr{N}(\mu, \sigma^2)\)
\begin{equation*}
\begin{split}f(x) = \frac{1}{\sqrt{2\pi\sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}} \ \sim \ e^{-\frac{(x-\mu)^2}{2\sigma^2}}\end{split}
\end{equation*}

\subsubsection{Distribuzione chi\sphinxhyphen{}quadrato, \protect\(\chi^2\protect\)}
\label{\detokenize{ch/statistics/pfun_continuous_examples:distribuzione-chi-quadrato-chi-2}}
\sphinxAtStartPar
Date \(n\) variabili casuali \(X_k\) indipendenti con distribuzione normale \(\mathscr{N}(0,1)\), la somma dei loro quadrati,
\begin{equation*}
\begin{split}\chi_n^2 = \sum_{k=1}^{n} X^2_k \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
è una variabile casuale con densità di probabilità \(\chi^2_n\), con \(n\) definito come il numero di gradi di libertà. La distribuzione \(\chi^2_n\) ha una pdf
\begin{equation*}
\begin{split}f(x) = \frac{1}{2^{\frac{n}{2}} \Gamma\left(\frac{n}{2}\right)} \, x^{\frac{n}{2}-1} \, e^{-\frac{x}{2}} \ \sim \ x^{\frac{n}{2}-1} \, e^{-\frac{n}{2}}\end{split}
\end{equation*}

\subsubsection{Distribuzione \protect\(t\protect\)\sphinxhyphen{}Student}
\label{\detokenize{ch/statistics/pfun_continuous_examples:distribuzione-t-student}}
\sphinxAtStartPar
La \(t\) di Student è la distribuzione di probabilità che governa il rapporto tra due variabili casuali indipendenti,
\begin{equation*}
\begin{split}t_{\nu} = \frac{Z}{\sqrt{\frac{K}{\nu}}} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
con il numeratore con distribuzione normale, \(Z \sim \mathscr{N}(0,1)\), e il denominatore con distribuzione chi quadrato, \(K \sim \chi^2_n\). La pdf è
\begin{equation*}
\begin{split}f(x) = \frac{\Gamma\left(\frac{n+1}{2}\right)}{\sqrt{n \, \pi} \, \Gamma\left(\frac{n}{2}\right)} \left( 1 + \frac{x^2}{n} \right)^{-\frac{n + 1}{2}} \ \sim \ \left( 1 + \frac{x^2}{n} \right)^{-\frac{n + 1}{2}} \ .\end{split}
\end{equation*}

\paragraph{Distrubuzione gaussiana come limite della distribuzione \protect\(t\protect\)\sphinxhyphen{}Student}
\label{\detokenize{ch/statistics/pfun_continuous_examples:distrubuzione-gaussiana-come-limite-della-distribuzione-t-student}}
\sphinxAtStartPar
Ricordandosi la definizione di \(e^x\) come limite della successione \(\lim_{n \rightarrow \infty} \left( 1 + \frac{x}{n} \right)^n =: e^x\), e usando l’approssimazione asintotica per \(n \rightarrow \infty\) della funzione Gamma \(\Gamma(n+\alpha) \sim \Gamma(n)n^{\alpha}\), si può dimostrare che
\begin{equation*}
\begin{split}\left( 1 + \frac{x^2}{n} \right)^{-\frac{n+1}{2}} = \left( 1 + \frac{x^2}{n} \right)^{-\frac{1}{2}} \left[ \left( 1 + \frac{x^2}{n} \right)^n \right]^{-\frac{1}{2}} \quad \rightarrow \quad 1 \cdot e^{-\frac{x^2}{2}}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\frac{\Gamma\left(\frac{n+1}{2}\right)}{\sqrt{n} \, \Gamma\left( \frac{n}{2} \right)} \sim
  \frac{\Gamma\left(\frac{n}{2}\right) \, \left(\frac{n}{2}\right)^{\frac{1}{2}}}{\sqrt{n} \, \Gamma\left( \frac{n}{2} \right)} = \frac{1}{\sqrt{2}} \ , \end{split}
\end{equation*}
\sphinxAtStartPar
e quindi la funzione \(t\)\sphinxhyphen{}Student tende alla distribuzione normale con valore atteso \(0\) e varianza unitaria,
\begin{equation*}
\begin{split}f(x) \sim \frac{1}{\sqrt{2 \,\pi}} e^{-\frac{x^2}{2}} \ .\end{split}
\end{equation*}
\sphinxstepscope


\subsection{Variabili casuali indipendenti e identicamente distribuite, iid.}
\label{\detokenize{ch/statistics/iid:variabili-casuali-indipendenti-e-identicamente-distribuite-iid}}\label{\detokenize{ch/statistics/iid::doc}}
\sphinxAtStartPar
Due variabili stochastiche \(X\), \(Y\) sono
\begin{itemize}
\item {} 
\sphinxAtStartPar
statisticamente indipendenti se la loro probabilità congiunta è uguale al prodotto delle probabilità marginali,
\begin{equation*}
\begin{split}p_{XY}(x,y) = p_X(x) \, p_Y(y) \ ,\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
identicamente distribuite se hanno la stessa densità di probabilità,
\begin{equation*}
\begin{split}p_X(x) = p_Y(x)\end{split}
\end{equation*}
\end{itemize}


\subsubsection{Teoremi sulle variabili casuali i.i.d.}
\label{\detokenize{ch/statistics/iid:teoremi-sulle-variabili-casuali-i-i-d}}
\sphinxAtStartPar
Dato un insieme di \(N\) variabili casuali iid \(\{ X_n \}_{n=1:N}\), con valore atteso \(E[X_n] = \mu\) e varianza \(E[(X_n - \mu)^2] = \sigma\), allora la sua media campionaria
\begin{equation*}
\begin{split}\bar{X}_N = \frac{1}{N} \sum_{n=1}^N X_n \ \end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
per il \sphinxstylestrong{teorema dei grandi numeri}, converge al valore atteso \(\mu\) della distribuzione di probabilità.

\item {} 
\sphinxAtStartPar
per il \sphinxstylestrong{teorema del limite centrale}, è una variabile casuale che converge in distribuzione a una variabile casuale gaussiana con valore atteso \(\mu\) e varianza \(\frac{\sigma^2}{n}\),
\begin{equation*}
\begin{split}\bar{X}_N \rightarrow \mathscr{N}\left(\mu, \frac{\sigma^2}{N} \right) \qquad , \qquad \text{as $N \rightarrow \infty$}\end{split}
\end{equation*}
\end{itemize}


\paragraph{Convergenza in statistica, \sphinxstylestrong{todo}}
\label{\detokenize{ch/statistics/iid:convergenza-in-statistica-todo}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{quasi certamente}. Esempio: teorema dei grandi numeri in forma forte. Il limite della media campionaria è diverso da una variabile casuale \(\mu\) (\sphinxstylestrong{todo} \sphinxstyleemphasis{controllare}!) solo nel caso di eventi di probabilità nulla,
\begin{equation*}
\begin{split}P\left( \lim_{N \rightarrow \infty} \bar{X}_N = \mu \right) = 1 \ .\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{in probabilità}. Esempio: teorema dei grandi numeri in forma debole. Per ogni valore di \(\varepsilon > 0\),
\begin{equation*}
\begin{split}P\left( \left|\lim_{N \rightarrow \infty} \bar{X}_N - \mu \right| < \varepsilon \right) = 1 \ .\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{convergenza in distribuzione}. Esempio: teorema del limite centrale…

\end{itemize}


\subsubsection{Esempio: teoremi dei grandi numeri e del limite centrale}
\label{\detokenize{ch/statistics/iid:esempio-teoremi-dei-grandi-numeri-e-del-limite-centrale}}

\paragraph{Librerie e funzioni}
\label{\detokenize{ch/statistics/iid:librerie-e-funzioni}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{Dimensione campione}
\label{\detokenize{ch/statistics/iid:dimensione-campione}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{Definizione delle variabili casuali}
\label{\detokenize{ch/statistics/iid:definizione-delle-variabili-casuali}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Stima della distribuzione di probabilità della media campionaria}
\label{\detokenize{ch/statistics/iid:stima-della-distribuzione-di-probabilita-della-media-campionaria}}
\sphinxAtStartPar
Per tutte le popolazioni definite sopra, vengono
\begin{itemize}
\item {} 
\sphinxAtStartPar
estratti \(N_s\) campioni,

\item {} 
\sphinxAtStartPar
valuata la media campionaria \(\{\overline{X}_s\}_{s = 1:N_s}\),

\item {} 
\sphinxAtStartPar
stimata la densità di probabilità \(f_{\overline{X}}(x)\),

\item {} 
\sphinxAtStartPar
calcolate le statistiche: media \(\mu_{\overline{x}}\), e variazione standard \(\sigma_{\overline{x}}^2\)

\end{itemize}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\begin{sphinxuseclass}{tag_hide-output}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{Grafici}
\label{\detokenize{ch/statistics/iid:grafici}}

\subparagraph{Deviazione standard della media campionaria}
\label{\detokenize{ch/statistics/iid:deviazione-standard-della-media-campionaria}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{91040efc1a240de84b037ef69384df448469163a10b2c3bea9ac76a5b9535f6e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subparagraph{Distribuzione di probabilità}
\label{\detokenize{ch/statistics/iid:distribuzione-di-probabilita}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 0.98, \PYGZsq{}Distribution of sample average, scaled\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{5dc9a248f8a4a10abf6e28d2892dc724d6d2e9bcb2672b9dbe0a7f745187a385}.png}

\noindent\sphinxincludegraphics{{afb6456f76a8eac818fbed1e107c511f2bfbe5c82d13f5eca36a8151923561be}.png}

\noindent\sphinxincludegraphics{{b847d6b0d327565bdb6354c3d0f94f656c6d081a07c11bc04c282f1b7306ac5c}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\subsection{Campionamento}
\label{\detokenize{ch/statistics/sampling:campionamento}}\label{\detokenize{ch/statistics/sampling::doc}}

\subsection{Media campionaria}
\label{\detokenize{ch/statistics/sampling:media-campionaria}}
\sphinxAtStartPar
La media campionaria di \(N\) campioni indipendenti identicametne distribuiti,
\begin{equation*}
\begin{split}\bar{X}_N = \frac{1}{N} \sum_{n=1}^{N} X_n \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
è una variabile casuale, che può essere usata come \sphinxstylestrong{stimatore senza bias della media} della popolazione. Uno \sphinxstylestrong{stimatore senza bias della varianza} è definito
\begin{equation*}
\begin{split}\hat{\sigma}^2_N = \frac{1}{N-1} \sum_{n=1}^N (X_n - \bar{X}_N)^2 \ .\end{split}
\end{equation*}

\subsection{Dimensione del campione, teorema del limite centrale e distribuzione \protect\(t\protect\)\sphinxhyphen{}Student}
\label{\detokenize{ch/statistics/sampling:dimensione-del-campione-teorema-del-limite-centrale-e-distribuzione-t-student}}
\sphinxAtStartPar
La media di \(N\) variabili iid con media \(\mu\) e varianza \(\sigma^2\) è una variabile casuale, la cui distribuzione di probabilità tende alla distribuzione normale \(\mathscr{N}\left(\mu, \frac{\sigma^2}{N} \right)\) per \(N \rightarrow \infty\).

\sphinxAtStartPar
Per un numero di campioni ridotti, nel caso la popolazione sia formata da variabili iid con distribuzione gaussiana, la distribuzione della variabile
\begin{equation*}
\begin{split}T_N = \frac{\bar{X} - \hat{X}}{\frac{\hat{\sigma}}{\sqrt{N}}} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
costruita con gli stimatori non\sphinxhyphen{}biased della media e della varianza, è una variabile casuale con distribuzione \sphinxstylestrong{\(t\)\sphinxhyphen{}Student} con \(N-1\) gradi di libertà. Al tendere di \(N \rightarrow \infty\), gli stimatori senza bias tendono ai valori veri delle statistiche della popolazione, e la variabile
\begin{equation*}
\begin{split}\frac{\bar{X} - \hat{X}}{\frac{\hat{\sigma}}{\sqrt{N}}} \sim \frac{\bar{X} - \mu}{\frac{\sigma}{\sqrt{N}}} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
tende alla distribuzione normale \(\mathscr{N}(0,1)\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy} \PYG{k}{as} \PYG{n+nn}{sp}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}


\PYG{k}{def} \PYG{n+nf}{sample\PYGZus{}to\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{  }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} evaluate pdf, from histogram, and normalizing with uniform integration rule \PYGZdq{}\PYGZdq{}\PYGZdq{}}
  \PYG{n}{hist}\PYG{p}{,} \PYG{n}{bin\PYGZus{}edges} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{histogram}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} get data from histogram}
  \PYG{n}{bin\PYGZus{}cen} \PYG{o}{=} \PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(} \PYG{n}{bin\PYGZus{}edges}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bin\PYGZus{}edges}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{p}{)}           \PYG{c+c1}{\PYGZsh{} bin center}
  \PYG{n}{d\PYGZus{}bin} \PYG{o}{=} \PYG{n}{bin\PYGZus{}edges}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bin\PYGZus{}edges}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}                       \PYG{c+c1}{\PYGZsh{} bin widt}
  \PYG{n}{pdf} \PYG{o}{=} \PYG{n}{hist} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{hist} \PYG{o}{*} \PYG{n}{d\PYGZus{}bin}\PYG{p}{)}                           \PYG{c+c1}{\PYGZsh{} normalization to get int pdf = 1}
  \PYG{k}{return} \PYG{n}{pdf}\PYG{p}{,} \PYG{n}{bin\PYGZus{}cen}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Population size}
\PYG{n}{pop\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{1000000}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Random number generators}
\PYG{n}{pop\PYGZus{}distribution} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normal}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{pop\PYGZus{}distribution} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{uniform}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{rng} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{default\PYGZus{}rng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{uniform}   \PYG{c+c1}{\PYGZsh{} Uniform distribution}
    \PYG{n}{rng\PYGZus{}params} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{low}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{high}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{pop\PYGZus{}size} \PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} \PYGZsq{}normal by default\PYGZsq{}}
    \PYG{n}{rng} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{default\PYGZus{}rng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{normal}    \PYG{c+c1}{\PYGZsh{} Normal distribution}
    \PYG{n}{rng\PYGZus{}params} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{loc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.} \PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{pop\PYGZus{}size} \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Generate population}
\PYG{n}{pop} \PYG{o}{=} \PYG{n}{rng}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{rng\PYGZus{}params}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sample\PYGZus{}size} \PYG{o}{=} \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{30} \PYG{p}{]}
\PYG{n}{n\PYGZus{}samples}   \PYG{o}{=} \PYG{l+m+mi}{10000}

\PYG{n}{sample\PYGZus{}avgs} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{sample\PYGZus{}vars} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{s\PYGZus{}s} \PYG{o+ow}{in} \PYG{n}{sample\PYGZus{}size}\PYG{p}{:}
    \PYG{n}{sample\PYGZus{}avg} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{sample\PYGZus{}var} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i\PYGZus{}s} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{sample\PYGZus{}avg} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{pop}\PYG{p}{[}\PYG{n}{i\PYGZus{}s}\PYG{o}{*}\PYG{n}{s\PYGZus{}s}\PYG{p}{:}\PYG{p}{(}\PYG{n}{i\PYGZus{}s}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s\PYGZus{}s}\PYG{p}{]}\PYG{p}{)} \PYG{p}{]}
        \PYG{n}{sample\PYGZus{}var} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[} \PYG{n}{np}\PYG{o}{.}\PYG{n}{var}\PYG{p}{(}\PYG{n}{pop}\PYG{p}{[}\PYG{n}{i\PYGZus{}s}\PYG{o}{*}\PYG{n}{s\PYGZus{}s}\PYG{p}{:}\PYG{p}{(}\PYG{n}{i\PYGZus{}s}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s\PYGZus{}s}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ddof}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{]}

    \PYG{n}{sample\PYGZus{}avgs} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[} \PYG{n}{sample\PYGZus{}avg} \PYG{p}{]}
    \PYG{n}{sample\PYGZus{}vars} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[} \PYG{n}{sample\PYGZus{}var} \PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} print(sample\PYGZus{}avgs)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{is\PYGZus{}s} \PYG{o+ow}{in} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample\PYGZus{}size}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ns} \PYG{o}{=} \PYG{n}{sample\PYGZus{}size}\PYG{p}{[}\PYG{n}{is\PYGZus{}s}\PYG{p}{]}
    \PYG{n}{var} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(} \PYG{n}{sample\PYGZus{}vars}\PYG{p}{[}\PYG{n}{is\PYGZus{}s}\PYG{p}{]} \PYG{p}{)} \PYG{o}{/} \PYG{n}{ns}
    \PYG{n}{scaled} \PYG{o}{=} \PYG{n}{sample\PYGZus{}avgs}\PYG{p}{[}\PYG{n}{is\PYGZus{}s}\PYG{p}{]}\PYG{o}{/}\PYG{n}{var}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{.5}
    \PYG{n}{bin\PYGZus{}width} \PYG{o}{=} \PYG{l+m+mf}{.2}\PYG{p}{;} \PYG{n}{n\PYGZus{}bins} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{scaled}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{scaled}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{bin\PYGZus{}width}\PYG{p}{)}
    \PYG{n}{f}\PYG{p}{,} \PYG{n}{x} \PYG{o}{=} \PYG{n}{sample\PYGZus{}to\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{scaled}\PYG{p}{,} \PYG{n}{bins}\PYG{o}{=}\PYG{n}{n\PYGZus{}bins}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{f}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{n}{is\PYGZus{}s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}n\PYGZus{}s\PYGZdl{} = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{ns}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{stats}\PYG{o}{.}\PYG{n}{t}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{ns}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{n}{is\PYGZus{}s}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}t\PYGZus{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{nu, }\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{nu =}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{ns}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{stats}\PYG{o}{.}\PYG{n}{norm}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{mathscr}\PYG{l+s+si}{\PYGZob{}N\PYGZcb{}}\PYG{l+s+s2}{(0,1)\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}5.0, 5.0)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{a412c8895b0bc26818bc3fca9c3ebddd2e6519e7ff9b7c073af3fecb1e7d6048}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Processi casuali}
\label{\detokenize{ch/statistics/random_processes:processi-casuali}}\label{\detokenize{ch/statistics/random_processes:statistics-hs-random-processes}}\label{\detokenize{ch/statistics/random_processes::doc}}
\sphinxAtStartPar
Un processo casuale può essere definito come una variabile casuale che dipende dalla variabile tempo \(t\), \(X(t)\).

\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{è probabile che i dettagli di questa sezione richiedano una conoscenza abbastanza approfondita della materia, e di alcuni strumenti matematici come le trasformate}

\sphinxAtStartPar
\sphinxstylestrong{todo}
\begin{itemize}
\item {} 
\sphinxAtStartPar
definizione

\item {} 
\sphinxAtStartPar
statistiche (in tempo e in frequenza) e definizioni (stazionarietà, ergodicità,…)

\item {} 
\sphinxAtStartPar
esempi:
\begin{itemize}
\item {} 
\sphinxAtStartPar
discreti: Markov

\item {} 
\sphinxAtStartPar
continui (e discretizzati al computer):
\begin{itemize}
\item {} 
\sphinxAtStartPar
white noise, Wiener

\item {} 
\sphinxAtStartPar
random walk, Brown

\item {} 
\sphinxAtStartPar
applicazioni:
\begin{itemize}
\item {} 
\sphinxAtStartPar
diffusione

\item {} 
\sphinxAtStartPar
white noise nei sistemi dinamici (risposte a forzanti stocastiche)

\end{itemize}

\end{itemize}

\end{itemize}

\end{itemize}

\sphinxstepscope


\chapter{Statistica inferenziale}
\label{\detokenize{ch/statistics/inference:statistica-inferenziale}}\label{\detokenize{ch/statistics/inference:statistics-hs-inference}}\label{\detokenize{ch/statistics/inference::doc}}
\sphinxAtStartPar
La statistica inferenziale si occupa di stabilire le caratteristiche di una popolazione dall’osservazione di un suo campione, usando gli strumenti del calcolo delle probabilità.



\sphinxAtStartPar
Esistono (almeno) due approcci alla statistica inferenziale: l’apporccio classico \sphinxstylestrong{frequentista}, e l’approccio \sphinxstylestrong{bayesiano}. Del secondo, ci si limita a dire che usa delle \sphinxstyleemphasis{conoscenze pregresse} sul fenomeno e che è stato reso praticabile dai recenti sviluppi nelle capacità di calcolo a disposizione. \sphinxstylestrong{todo} \sphinxstyleemphasis{aggiungere sezione sull’approccio bayesiano?}

\sphinxAtStartPar
Tra le applicazioni della statistica inferenziale si possono distinguere due applicazioni principali:

\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{Scelta modello? Serve una discuterne? Rimandato a ML?}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{ch/statistics/estimate:statistics-hs-inference-estimate}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{stima}}}}} di parametri di una popolazione, noto un campione di essa:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{valori puntuali}, come ad esempio la media o la varianza di una popolazione

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{intervalli}, come ad esempio gli intervalli di confidenza

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{ch/statistics/hp-test:statistics-hs-inference-hp-test}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxstylestrong{verifica ipotesi}}}}}. La verifica delle ipotesi è un’attività intimamente connessa al metodo sperimentale e alla formazione della conoscenza nella storia umana secondo criteri logici. Nonostante sia poco sensata una classificazione rigida delle attività che coinvolgono la verifica delle ipotesi (seguendo la documentazione di \(\texttt{scipy.stats}\)), si possono distinguere
\begin{itemize}
\item {} 
\sphinxAtStartPar
test su \sphinxstylestrong{campioni singoli} o \sphinxstylestrong{coppie di campioni}: \(t\)\sphinxhyphen{}test, Wilcoxon,…

\item {} 
\sphinxAtStartPar
test di \sphinxstylestrong{correlazione}: LS, Pearson \(r\)\sphinxhyphen{}test, Spearman \(r\)\sphinxhyphen{}test,

\item {} 
\sphinxAtStartPar
test di \sphinxstylestrong{indipendenza}, verifica se i campioni provengono dalla stessa popolazione (e quindi dalla stessa distribuzione), o da popolazioni con distribuzioni con proprietà in comune: ANOVA, Kruskali\sphinxhyphen{}Wallis, Tukey

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ri\sphinxhyphen{}campionamento} e metodi MC: per valutare \(p\)\sphinxhyphen{}value e intervalli di confidenza test di validità di ipotesi

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{ipotesi multiple}

\end{itemize}

\end{itemize}





\sphinxstepscope


\section{Stima}
\label{\detokenize{ch/statistics/estimate:stima}}\label{\detokenize{ch/statistics/estimate:statistics-hs-inference-estimate}}\label{\detokenize{ch/statistics/estimate::doc}}

\subsection{Stimatori}
\label{\detokenize{ch/statistics/estimate:stimatori}}
\sphinxAtStartPar
Uno stimatore \(\hat{\theta}(\mathbf{x})\) è una statistica, funzione dei dati del campione osservato \(\mathbf{x} = \{ x_n \}_{n=1:N}\), che viene usata per dedurre il valore di un parametro della distribuzione di probabilità della popolazione, \(p(x|\theta)\), funzione del parametro.

\sphinxAtStartPar
\sphinxstylestrong{Bias}. Il bias di uno stimatore è la differenza tra il valore atteso dello stimatore \(E[ \hat{\theta} ]\) e il valore del parametro \(\theta\),
\begin{equation*}
\begin{split}B(\hat{\theta}) := E[ \hat{\theta} ] - \theta \ .\end{split}
\end{equation*}

\subsubsection{Media e varianza campionaria senza bias}
\label{\detokenize{ch/statistics/estimate:media-e-varianza-campionaria-senza-bias}}
\sphinxAtStartPar
Dato un campione \(\mathbf{x} = \{ x_n \}_{n=1:N}\) di \(N\) osservazioni indipendenti estratto da una popolazione, la media campionaria \(\bar{X}\) e la varianza campionaria corretta \(S^2\),
\begin{equation*}
\begin{split}\bar{X} := \frac{1}{N} \sum_{n = 1}^{N} X_n \qquad , \qquad S^2 := \frac{1}{N-1} \sum_{n=1}^N (X_n - \bar{X})^2 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
sono stimatori senza bias della media, \(\hat{\mu}\), e della varianza della variabile osservata della popolazione, \(\hat{\sigma^2}\). Le singole osservazioni possono essere dei dati generati in maniera indipendente con uguale distribuzione di probabilità.

\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstylestrong{oss.} Dalle dimostrazioni, sembra che l’identica distribuzione non sia strettamente necessaria, ma che siano richieste: indipendenza (e non correlazione) delle variabili che producono l’ossservazione; variabili con stesso valore di media e di varianza, indipendentemente dalla «forma» della distribuzione di probabilità.
\subsubsection*{Dimostrazione per la media}

\sphinxAtStartPar
Dato un campione di \(n\) variabili indipendenti \(\{ X_n \}_n{1:N}\) osservate in una popolazione con media \(\mu = E[X]\), e varianza \(\sigma^2 = E\left[ (X-\mu)^2 \right]\), allora la media campionaria \(\bar{X}\) è uno stimatore senza bias \(\hat{\mu}\) della media \(\mu = E[X]\) della popolazione. Il valore atteso della media campionaria coincide con la media della popolazione,
\begin{equation*}
\begin{split}\begin{aligned}
  E[\bar{X}] 
  & = E\left[ \frac{1}{N} \sum_{n=1}^N X_n \right]
    = \frac{1}{N} \sum_{n=1}^N E\left[ X_n \right] = \frac{1}{N} \, N \, \mu = \mu \ .
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
e quindi il bias di questo stimatore è nullo, \(B(\hat{\mu}) = E[\hat{\mu}] - \mu = 0\).
\subsubsection*{Dimostrazione per la varianza}

\sphinxAtStartPar
Dato un campione di \(n\) variabili indipendenti \(\{ X_n \}_n{1:N}\) osservate in una popolazione con media \(\mu = E[X]\), e varianza \(\sigma^2 = E\left[ (X-\mu)^2 \right]\), allora la varianza campionaria corretta \(S^2\) è uno stimatore senza bias \(\hat{\sigma^2}\) della varianza \(\sigma^2 = E[(X-\mu)^2]\) della popolazione. Per dimostrare questa affermazione, si usa la proprietà della covarianza
\begin{equation*}
\begin{split}E[(X_i-\mu_i)(X_j-\mu_j)] = E[X_i X_j] - \mu_i E[X_j] - \mu_j E[X_i] + \mu_i \mu_j = E[X_i X_j] - \mu_i \mu_j \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
che, nel caso di variabili indipendenti non correlate con uguale varianza, si riduce a
\begin{equation*}
\begin{split} E[X_i X_j] = \sigma^2 \delta_{ij} + \mu_i \mu_j\end{split}
\end{equation*}
\sphinxAtStartPar
Il valore atteso della varianza campionaria corretta convide con la varianza della popolazione,
\begin{equation*}
\begin{split}\begin{aligned}
  (N-1) E[S^2] 
  & = E\left[ \sum_{n=1}^N ( X_n - \bar{X} )^2 \right] = \\
  & = E\left[ \sum_{n=1}^N \left( X_n - \frac{1}{N} \sum_{m=1}^N X_m \right)^2 \right] = \\
  & = E\left[ \sum_{n=1}^N X_n^2 + \sum_{m=1}^N \left( - \frac{2}{N} X_n X_m + \frac{2}{N^2} \sum_{p \ne m} X_m X_p + \frac{X_m^2}{N^2} \right) \right] = \\
  & = \sum_{n=1}^N E[X_n^2] + \sum_{n,m=1}^N \left( -\frac{2}{N} E[X_n X_m] + \frac{1}{N^2}E[X_m^2] \right) - \frac{2}{N^2} \sum_{n,m=1}^N \sum_{p > m} E [ X_m X_p ] = \\
  & = \sum_{n=1}^N ( \sigma^2 + \mu^2 ) + \sum_{n,m=1}^N \left( -\frac{2}{N} \left( \sigma^2 \delta_{nm} + \mu^2 \right) + \frac{1}{N^2} \left( \sigma^2 + \mu^2 \right) \right) + \frac{2}{N^2} \sum_{n,m=1}^N \sum_{p > m} \left( \sigma^2 \delta_{mp} + \mu^2 \right) = \\
  & = N (\sigma^2 + \mu^2) - \frac{2}{N} \left( N \sigma^2 + N^2 \mu^2 \right) + \frac{1}{N^2} N^2 (\sigma^2 + \mu^2) + \frac{2}{N^2} \frac{N^2(N-1)}{2} \mu^2 = \\
  & = \sigma^2 (N-1) + \mu^2 \left( N - 2N + 1 + N - 1 \right) \\
  & = \sigma^2 (N-1) \ . \\ 
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
e quindi, dividendo per il fattore \(N-1\) entrambi i termini, segue la dimostrazione che la varianza campionaria corretta per la varianza della popolazione è uno stimatore con bias nullo, \(B(\hat{\sigma^2}) = E[\hat{\sigma^2}] - \sigma^2 = 0\).



\sphinxstepscope


\section{Test di verifica delle ipotesi}
\label{\detokenize{ch/statistics/hp-test:test-di-verifica-delle-ipotesi}}\label{\detokenize{ch/statistics/hp-test:statistics-hs-inference-hp-test}}\label{\detokenize{ch/statistics/hp-test::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Popper.} Filosofia della scienza e principio di falsificabilità.

\sphinxAtStartPar
\sphinxstylestrong{Fisher.} Viene formulata un’ipotesi falsificabile, chiamata \sphinxstylestrong{ipotesi nulla}, \(\text{H}_{0}\), che viene ritenuta vera fino a prova contraria. Il test di verifica delle ipotesi ha l’obiettivo di verificare se i dati disponibili, riassunti in una variabile test, possono smentire l’ipotesi con una probabilità desiderata.
\subsubsection*{Test di verifica di Fisher}

\sphinxAtStartPar
Il test di verifica di un’ipotesi di Fisher si ispira al principio di falsificabilità di Popper, e può essere riassunto nei seguenti passaggi:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
formulazione di un’ipotesi falsificabile, definita \sphinxstylestrong{ipotesi nulla}, \(\text{H}_0\), da verificare e che viene ritenuta vera fino a prova contraria

\item {} 
\sphinxAtStartPar
scelta di una \sphinxstylestrong{statistica test}, \(x\), o variabile esplicativa, un parametro disponibile rilevante per il fenomeno indagato e di cui è nota \sphinxhyphen{} o approssimabile, sotto ipotesi ragionevoli sul fenomeno \sphinxhyphen{} la distribuzione di probabilità condizionata alla validità dell’ipotesi nulla,

\end{enumerate}
\begin{equation*}
\begin{split}p(x|\text{H}_0) \ .\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
scelta del test statistico (es. una coda o due code,…), in base anche alle caratteristiche del fenomeno indagato

\item {} 
\sphinxAtStartPar
scelta del livello di \sphinxstylestrong{significatività}, \(\alpha\), del test; il valore del livello di significatività traduce «il livello di evidenza richiesto» per falsificare l’ipotesi e \sphinxhyphen{} insieme alle caratteristiche del fenomeno e del test \sphinxhyphen{} determina le \sphinxstyleemphasis{regioni di rifiuto}, \(A_r(\alpha)\), e di \sphinxstyleemphasis{accettazione dell’ipotesi}, \(A_a(\alpha)\), gli intervalli di valori della statistica test che determinano se l’ipotesi è stata falsificata o meno;

\item {} 
\sphinxAtStartPar
raccolta dati e calcolo statistica test sul campione, \(x_s\)

\item {} 
\sphinxAtStartPar
confronto del valore calcolato della statistica test con gli intervalli di rifiuto e accettazione della variabile soggetta all’ipotesi nulla, e verdetto sull’ipotesi,
\begin{equation*}
\begin{split}\begin{aligned}
      x_s \in A_r(\alpha) \qquad & \rightarrow \qquad \text{ il test falsifica $\text{H}_0$, che deve essere scartata} \\
      x_s \in A_a(\alpha) \qquad & \rightarrow \qquad \text{ il test non falsifica $\text{H}_0$} \\
    \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
All’aumentare del livello di significatività del test richiesto, si riduce la regione di falsificazione e quindi diventano più stringenti i requisiti sul test per scartare l’ipotesi di partenza.

\end{enumerate}

\sphinxAtStartPar
Usando questo approccio, è possibile distinguere diversi test a seconda dei dati disponibili (numero di campioni, dimensione dei campioni, distribuzione attesa delle osservazioni,…), della variabile test utilizzata, e dell’obiettivo del test. Una classificazione rigida dettagliata rischierebbe di risultare poco pratica e imperfetta.

\sphinxAtStartPar
\sphinxstylestrong{Usi frequenti.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
le proprietà di campioni singoli o coppie di campioni

\item {} 
\sphinxAtStartPar
la correlazione tra campioni diversi

\item {} 
\sphinxAtStartPar
l”\sphinxstyleemphasis{indipendenza} dei campioni, intesa come verifica se i campioni disponibili provengono dalla stessa popolazione o da popolazioni con distribuzioni con proprietà in comune

\end{itemize}





\sphinxstepscope




\subsection{Test su campioni singoli o coppie di campioni}
\label{\detokenize{ch/statistics/hp-test-single:test-su-campioni-singoli-o-coppie-di-campioni}}\label{\detokenize{ch/statistics/hp-test-single::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Test più comuni}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(t\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
\(\chi^2\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
\(Z\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
Wilcoxon

\item {} 
\sphinxAtStartPar
…

\end{itemize}


\subsubsection{Student \protect\(t\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-single:student-t-test}}
\sphinxAtStartPar
I \(t\)\sphinxhyphen{}test sono dei test statistici di posizione in cui la statistica test segue una distribuzione \(t\) di Student sotto l’ipotesi nulla \(\text{H}_0\),
\begin{equation*}
\begin{split}p(t|\text{H}_0) \sim t_{\nu} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
dove il numero di gradi di libertà \(\nu\) della distribuzione \(t_{\nu}\) dipende dal metodo considerato.

\sphinxAtStartPar
\sphinxstylestrong{Ipotesi.} …

\sphinxAtStartPar
\sphinxstylestrong{Test a un campione.} E” un test di posizione/stima della media della popolazione della quale è noto un campione di \(n\) osservazioni.
\begin{itemize}
\item {} 
\sphinxAtStartPar
l’ipotesi nulla \(\text{H}_0\) dichiara che la popolazione ha media \(\mu_0\);

\item {} 
\sphinxAtStartPar
la statistica test \(t\) è costruita con la media e la varianza campionaria \(\overline{x}\), \(S^2\),
\begin{equation*}
\begin{split}t = \frac{\overline{x} - \mu_0}{\frac{S}{\sqrt{n}}} \ ,\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
il numero di gradi di libertà è \(n-1\) \sphinxstylestrong{todo}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{oss.} se … \(t\) segue una distribuzione \(t_{n-1}\) di Student \sphinxstylestrong{todo} \sphinxstyleemphasis{inserire nelle ipotesi}, \sphinxstyleemphasis{riferimenti a definizione della distribuzione \(t\) e al campionamento e i teoremi relativi}

\item {} 
\sphinxAtStartPar
una volta definito il livello di significatività del test, \(\alpha\), si controlla se la statistica test \(t\) valutata con il campione a disposizione cade nella regione di rifiuto dell’ipotesi della distribuzione \(t_{n-1}\) o meno, per determinare se si deve considerare \(\text{H}_0\) falsificata dal test o meno

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Test a coppie di campioni.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Indipendenti} …\sphinxstylestrong{todo}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dipendenti} …\sphinxstylestrong{todo}

\end{itemize}


\subsubsection{\protect\(Z\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-single:z-test}}
\sphinxAtStartPar
Test identico al \(t\)\sphinxhyphen{}test in cui la statistica test \(z\) segue una distribuzione gaussiana sotto l’ipotesi nulla. Per il legame esistente tra la distribuzione \(t_{\nu}\) e \(\mathscr{N}\), si può interpretare lo \(Z\)\sphinxhyphen{}test come limite del \(t\)\sphinxhyphen{}test per un numero di campioni sufficientemente grande.


\subsubsection{\protect\(\chi^2\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-single:chi-2-test}}
\sphinxAtStartPar
Il test \(\chi^2\) viene utilizzato per confrontare le frequenze osservate \(o_k\) e attese \(e_k\) di un insieme di possibili eventi, \(\{ E_k \}_{k=1:K}\). L’ipotesi nulla \(\text{H}_0\) afferma che il fenomeno osservato segue la distribuzione di probabilità descritta dalle frequenze attese. La statistica test è
\begin{equation*}
\begin{split}X^2 = \sum_{k=1}^{K} \frac{(o_k - e_k)^2}{e_k}\end{split}
\end{equation*}
\sphinxAtStartPar
Nel caso in cui le frequenze attese sono «sufficientemente grandi» e quelle osservate \(o_k\) abbiano una distribuzione gaussiana, allora \(X^2\) segue una distribuzione \(\chi^2_{K-1}\).

\sphinxAtStartPar
… \sphinxstylestrong{todo}


\subsubsection{Wilcoxon}
\label{\detokenize{ch/statistics/hp-test-single:wilcoxon}}
\sphinxAtStartPar
…\sphinxstylestrong{todo}

\sphinxstepscope


\subsection{Test di correlazione}
\label{\detokenize{ch/statistics/hp-test-correlation:test-di-correlazione}}\label{\detokenize{ch/statistics/hp-test-correlation::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Test più comuni}
\begin{itemize}
\item {} 
\sphinxAtStartPar
regressione lineare

\item {} 
\sphinxAtStartPar
correlazione di Pearson

\item {} 
\sphinxAtStartPar
correlazione di Spearman

\end{itemize}


\subsubsection{Regressione lineare}
\label{\detokenize{ch/statistics/hp-test-correlation:regressione-lineare}}\begin{itemize}
\item {} 
\sphinxAtStartPar
regressione lineare

\item {} 
\sphinxAtStartPar
regressione lineare generalizzata

\item {} 
\sphinxAtStartPar
…

\end{itemize}


\paragraph{Metodo dei minimi quadrati per una regressione lineare}
\label{\detokenize{ch/statistics/hp-test-correlation:metodo-dei-minimi-quadrati-per-una-regressione-lineare}}
\sphinxAtStartPar
Dati due campioni accoppiati \(\{X_n\}_{n=1:N}\), \(\{Y_n\}_{n=1:N}\) campionati dalle popolazioni \(X\), \(Y\), si calcolano i coefficienti \(\symbf{\theta} = (a, b)\) dell’approssimazione lineare \(y(x|\theta) = a x + b\) che rendono minimo l’errore quadratico medio
\begin{equation*}
\begin{split}e(\symbf{\theta}) = \frac{1}{2 N} \sum_{n=1}^{N} (y(x_n|\symbf{\theta}) - y_n)^2 =  \frac{1}{2 N} \sum_{n=1}^{N} (a x_n + b - y_n)^2 \ .\end{split}
\end{equation*}
\sphinxAtStartPar
La funzione è quadratica in \(a\), \(b\) e semi\sphinxhyphen{}definita positiva. Si cercano i valori che rendono minimo l’errore ponendo uguale a \(0\) le derivate parziali dell’errore rispetto ai parametri
\begin{equation*}
\begin{split}\begin{aligned}
  0 & = \frac{\partial e}{\partial a} = \frac{1}{N} \sum_{n=1}^N x_n (a x_n + b - y_n) = \frac{1}{N} \sum_{n=1}^N x^2_n \, a + \frac{1}{N} \sum_{n=1}^N x_n \, b - \frac{1}{N} \sum_{n=1}^{N} x_n y_n \\
  0 & = \frac{\partial e}{\partial b} = \frac{1}{N} \sum_{n=1}^N (a x_n + b - y_n)     = \frac{1}{N} \sum_{n=1}^N x_n \, a + b - \frac{1}{N} \sum_{n=1}^{N} y_n \\
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
Queste due equazioni formano un sistema lineare di due equazioni in due incognite, che può essere riscritto con il formalismo matriciale
\begin{equation*}
\begin{split}\begin{bmatrix} \frac{1}{N} \sum_{n=1}^N x^2_n & \frac{1}{N} \sum_{n=1}^N x_n  \\ \frac{1}{N} \sum_{n=1}^N x_n & 1 \end{bmatrix} \begin{bmatrix} a \\ b \end{bmatrix} = \begin{bmatrix} \frac{1}{N} \sum_{n=1}^{N} x_n y_n \\ \frac{1}{N} \sum_{n=1}^{N} y_n \end{bmatrix} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Il valore dei coefficienti ottimi \(\theta^* = (a, b)\) che minimizzano l’errore quadratico medio si trova come soluzione del sistema lineare, l’errore quadratico medio minimo dovuto all’approssimazione viene calcolato in seguito, \(e(\theta^*)\). La bontà dell’approssimazione lineare può essere valutata in termini dell’errore quadratico medio.

\sphinxAtStartPar
\sphinxstylestrong{Regressione e SL.} Una delle applicazioni fondamentali in ML, in particolare in SL, è la regressione o l’approssimazione di funzioni; scelta del modello…


\paragraph{Metodo ed errore}
\label{\detokenize{ch/statistics/hp-test-correlation:metodo-ed-errore}}
\sphinxAtStartPar
Il sistema lineare può essere riscritto come
\begin{equation*}
\begin{split}\begin{bmatrix} \frac{1}{N} \sum_{n=1}^N x^2_n & \bar{x}  \\ \bar{x} & 1 \end{bmatrix} \begin{bmatrix} a \\ b \end{bmatrix} = \begin{bmatrix} \frac{1}{N} \sum_{n=1}^{N} x_n y_n \\ \bar{y} \end{bmatrix} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e la soluzione
\begin{equation*}
\begin{split}\begin{aligned}
 \begin{bmatrix} a \\ b \end{bmatrix} & = \frac{1}{\frac{1}{N} \sum_{n=1}^N x^2_n - \bar{x}^2} \begin{bmatrix} 1 & -\bar{x}  \\ -\bar{x} & \frac{1}{N} \sum_{n=1}^N x^2_n \end{bmatrix} \, \begin{bmatrix} \frac{1}{N} \sum_{n=1}^{N} x_n y_n \\ \bar{y} \end{bmatrix} = \\
 & = \frac{1}{\frac{1}{N} \sum_{n=1}^N x^2_n - \bar{x}^2} \begin{bmatrix} \frac{1}{N} \sum_{n=1}^N x_n y_n - \bar{x}\bar{y} \\ -\frac{\bar{x}}{N} \sum_{n=1}^N x_n y_n + \frac{\bar{y}}{N} \sum_{n=1}^N x_n^2 \end{bmatrix} = \\
 & = \frac{1}{R_x - \bar{x}^2} \begin{bmatrix} R_{xy} - \bar{x} \bar{y} \\ -\bar{x} R_{xy} + \bar{y} R_x \end{bmatrix}
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
L’errore minimo diventa quindi
\begin{equation*}
\begin{split}\begin{aligned}
  e & = \frac{1}{2N} \sum_{m=1}^{N} \left( a \, x_m  + b -  y_m \right)^2 = \\
    & = \frac{1}{2 N} \sum_{m=1}^N \left( a^2 x_m^2 + b^2 + y_m^2 + 2 a b x_m - 2 b y_m - 2 a x_m y_m  \right) \\
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned}
2 e & = \frac{1}{N} \left[ a^2 \sum_{m=1}^{N} x_m^2 + N b^2 + \sum_{m=1}^N y_m^2 + 2 a b \bar{x} - 2 b \bar{y} - 2 a \sum_{m=1}^{N} x_m y_m  \right] = \\
  & = a^2 R_x + b^2 + R_y + 2 a b \bar{x} - 2 b \bar{y} - 2 a R_{xy} \\
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned}
2 e & = \left( \frac{R_{xy} - \bar{x} \bar{y}}{R_x - \bar{x}^2} \right)^2 R_x + \left( \frac{-\bar{x} R_{xy} + \bar{y} R_x}{R_x - \bar{x}^2} \right)^2 + R_y + 2 \left( \frac{R_{xy} - \bar{x} \bar{y}}{R_x - \bar{x}^2} \right) \left( \frac{-\bar{x} R_{xy} + \bar{y} R_x}{R_x - \bar{x}^2} \right) \bar{x} - 2 \left( \frac{-\bar{x} R_{xy} + \bar{y} R_x}{R_x - \bar{x}^2} \right) \bar{y} - 2 \left( \frac{R_{xy} - \bar{x} \bar{y}}{R_x - \bar{x}^2} \right) R_{xy} \\
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}
2 e = \frac{1}{D^2}\left[ R_{xy}^2 R_x - 2 x y R_{xy} R_x + x^2 y^2 R_x + \dots \right]
\end{split}
\end{equation*}

\subsubsection{Correlazione di Pearson}
\label{\detokenize{ch/statistics/hp-test-correlation:correlazione-di-pearson}}
\sphinxAtStartPar
Il \sphinxstylestrong{coefficiente di correlazione} tra due variabili casuali \(X\), \(Y\) è definito come il rapporto tra la loro covarianza e il prodotto delle loro deviazioni standard,
\begin{equation*}
\begin{split}\rho_{XY} = \frac{\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}(Y))]}{\sqrt{\mathbb{E}[(X-\mathbb{E}[X])^2]}\sqrt{\mathbb{E}[(Y-\mathbb{E}[Y])^2]}} = \frac{\sigma^2_{XY}}{\sigma_X \, \sigma_Y} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Coefficiente di correlazione per campioni.} Usando le statistiche campionarie per i campioni a disposizione delle due popolazioni,
\begin{equation*}
\begin{split}\begin{aligned}
  r_{xy} 
  & = \frac{\frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})(y_i - \bar{y})}{ \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (x_i - \bar{x})^2}\sqrt{ \frac{1}{n-1} \sum_{i=1}^{n} (y_i - \bar{y})^2}} = \\
  & = \frac{1}{n-1} \sum_{i=1}^n \left( \frac{x_i - \bar{x}}{S_x} \right) \left( \frac{y_i - \bar{y}}{S_y} \right) = \\
  & = \frac{ \sum_{i=1}^{n} (x_i - \bar{x})(y_i - \bar{y})}{ \sqrt{\sum_{i=1}^{n} (x_i - \bar{x})^2}\sqrt{ \sum_{i=1}^{n} (y_i - \bar{y})^2}} \ .
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Coefficiente di correlazione in statistica inferenziale.} I metodi di statistica basati sul coefficiente di correlazione di Pearson hanno due obiettivi:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
valutare l’ipotesi nulla \(\text{H}_0\) che afferma che l’assenza di correlazione tra le due popolazioni, \(\rho = 0\), sulla base del valore del coefficiente \(r\) calcolato sui campioni

\item {} 
\sphinxAtStartPar
fornire un intervallo di confidenza che contenga \(\rho\)

\end{enumerate}

\sphinxAtStartPar
Alcuni metodi per ottenere questi due obiettivi sono:
\begin{itemize}
\item {} 
\sphinxAtStartPar
permutazione

\item {} 
\sphinxAtStartPar
bootstrap

\item {} 
\sphinxAtStartPar
errore standard, assumendo una relazione lineare tra \(x\) e \(y\), con l’aggiunta di un errore gaussiano \(\varepsilon\), \(y = a x + b + \varepsilon\), \(\sigma_r = \sqrt{\frac{1-r^2}{n-2}}\)

\item {} 
\sphinxAtStartPar
\(t\)\sphinxhyphen{}test sulla variabile \(t = \frac{r}{\sigma_r}\)

\item {} 
\sphinxAtStartPar
…

\end{itemize}


\subsubsection{Correlazione di Spearman}
\label{\detokenize{ch/statistics/hp-test-correlation:correlazione-di-spearman}}\begin{itemize}
\item {} 
\sphinxAtStartPar
per ranghi

\item {} 
\sphinxAtStartPar
per relazioni non lineari ma monotone
… \sphinxstylestrong{todo}

\end{itemize}


\subsubsection{Esempio}
\label{\detokenize{ch/statistics/hp-test-correlation:esempio}}
\sphinxAtStartPar
Si valutano i metodi di correlazione per 4 coppie di campioni, 2 che mostrano una buona correlazione e 2 con correlazione scarsa

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} Pair 0
  Regression coeffs y = 0.7673 x + 0.0527, with error 0.0831
  Pearson correlation: 0.9977, sigma: 0.0228
\PYGZgt{} Pair 1
  Regression coeffs y = \PYGZhy{}0.9364 x + 1.0500, with error 0.0477
  Pearson correlation: \PYGZhy{}0.9995, sigma: 0.0107
\PYGZgt{} Pair 2
  Regression coeffs y = \PYGZhy{}0.0604 x + 0.2410, with error 1.1254
  Pearson correlation: \PYGZhy{}0.0882, sigma: 0.3320
\PYGZgt{} Pair 3
  Regression coeffs y = 0.3824 x + 0.4404, with error 0.9296
  Pearson correlation: 0.5614, sigma: 0.2758
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(44.222222222222214, 0.5, \PYGZsq{}y\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{c0219b89b3d25a5058c0fbeefb64ea7d58c995c486dbf4899c1f7c583a3583e7}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\subsection{Test di indipendenza}
\label{\detokenize{ch/statistics/hp-test-independence:test-di-indipendenza}}\label{\detokenize{ch/statistics/hp-test-independence::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Test più comuni}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(t\)\sphinxhyphen{}test per campionoi indipendenti e Welch \(t\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
ANOVA

\item {} 
\sphinxAtStartPar
Tukey test

\item {} 
\sphinxAtStartPar
Mann\sphinxhyphen{}Whitney \(U\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
Kruskal\sphinxhyphen{}Wallis \(H\)\sphinxhyphen{}test

\end{itemize}


\subsubsection{\protect\(t\protect\)\sphinxhyphen{}test e Welch \protect\(t\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-independence:t-test-e-welch-t-test}}
\sphinxAtStartPar
Il \(t\)\sphinxhyphen{}test di Welch è un test di posizione per stimare se due popolazioni di cui sono noti due campioni hanno la stessa media. E” una modifica del \(t\)\sphinxhyphen{}test, e si dimostra un criterio più affidabile quando i due campioni hanno varianza diversa e dimensione diversa.

\sphinxAtStartPar
\sphinxstylestrong{Ipotesi.} Il test assume che la media dei campioni abbia una distribuzione normale.

\sphinxAtStartPar
…\sphinxstylestrong{todo}


\subsubsection{ANOVA (Analysis of variance)}
\label{\detokenize{ch/statistics/hp-test-independence:anova-analysis-of-variance}}\begin{itemize}
\item {} 
\sphinxAtStartPar
…insieme di metodi statistici…

\item {} 
\sphinxAtStartPar
differenza tra due o più campioni

\item {} 
\sphinxAtStartPar
i metodi più semplici valutano se le medie di 2 o più popolazioni hanno valori uguali

\item {} 
\sphinxAtStartPar
3 classi: fixed\sphinxhyphen{}effect, random\sphinxhyphen{}effect, mixed\sphinxhyphen{}effect

\item {} 
\sphinxAtStartPar
\(F\)\sphinxhyphen{}test

\item {} 
\sphinxAtStartPar
single/multiple factors

\item {} 
\sphinxAtStartPar
caso particolare di regressione lineare generalizzata

\end{itemize}

\sphinxAtStartPar
…\sphinxstylestrong{todo}


\subsubsection{Tukey test}
\label{\detokenize{ch/statistics/hp-test-independence:tukey-test}}
\sphinxAtStartPar
…\sphinxstylestrong{todo}


\subsubsection{Kruskal\sphinxhyphen{}Wallis \protect\(H\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-independence:kruskal-wallis-h-test}}
\sphinxAtStartPar
…\sphinxstylestrong{todo}


\subsubsection{Mann\sphinxhyphen{}Whitney \protect\(U\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/hp-test-independence:mann-whitney-u-test}}
\sphinxAtStartPar
Il test di Mann\sphinxhyphen{}Whitney è un test statistico non parametrico usato per verificare se le popolazioni \(X\), \(Y\) delle quali sono disponibili due campioni \(\{X_n\}_{n=1:n_x}\), \(\{Y_m\}_{m=1:n_y}\), sono identiche.

\sphinxAtStartPar
… \sphinxstylestrong{todo}

\sphinxstepscope


\subsection{Esempi}
\label{\detokenize{ch/statistics/hp-test-examples:esempi}}\label{\detokenize{ch/statistics/hp-test-examples::doc}}
\sphinxAtStartPar
…

\sphinxstepscope


\subsubsection{Test di verifica d’ipotesi \sphinxhyphen{} Fisher}
\label{\detokenize{ch/statistics/test-fisher-coin-1:test-di-verifica-d-ipotesi-fisher}}\label{\detokenize{ch/statistics/test-fisher-coin-1::doc}}
\sphinxAtStartPar
Il test di verifica di un’ipotesi di Fisher si ispira al principio di falsificabilità di Popper, e può essere riassunto nei seguenti passaggi:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
formulazione di un’ipotesi falsificabile, definita \sphinxstylestrong{ipotesi nulla} \(\text{H}_0\), da verificare e che viene ritenuta vera fino a prova contraria

\item {} 
\sphinxAtStartPar
scelta di una variabile esplicativa, o \sphinxstylestrong{statistica test}, \(x\), un parametro disponibile, rilevante per il fenomeno indagato e di cui è nota \sphinxhyphen{} o approssimabile, sotto ipotesi ragionevoli sul fenomeno \sphinxhyphen{} la distribuzione di probabilità,
\$\(p(x|\text{H}_0)\)\$

\item {} 
\sphinxAtStartPar
scelta del \sphinxstylestrong{test statistico} (es. una coda o due code,…), in base anche alle caratteristiche del fenomeno indagato

\item {} 
\sphinxAtStartPar
scelta del \sphinxstylestrong{livello di significatività}, \(\alpha\), del test; il valore del livello di significatività traduce «il livello di evidenza richiesto» per falsificare l’ipotesi e \sphinxhyphen{} insieme alle caratteristiche del fenomeno e del test \sphinxhyphen{} determina le \sphinxstyleemphasis{regioni di rifiuto e di accettazione dell’ipotesi}, gli intervalli di valori della statistica test \(x\) che determinano se l’ipotesi è stata falsificata o meno;

\item {} 
\sphinxAtStartPar
raccolta dati e \sphinxstylestrong{calcolo statistica test sul campione}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{confronto} del valore calcolato della statistica test con gli intervalli di rifiuto e accettazione della variabile soggetta all’ipotesi nulla, e \sphinxstylestrong{verdetto sull’ipotesi}

\end{enumerate}


\paragraph{Esempio: moneta truccata o no?}
\label{\detokenize{ch/statistics/test-fisher-coin-1:esempio-moneta-truccata-o-no}}
\sphinxAtStartPar
Dati i risultati di \(n\) lanci di una moneta, si vuole stabilire con una certa probabilità se la moneta è truccata o meno.

\sphinxAtStartPar
Il lancio di una moneta viene modellato come una variabile casuale \(X\) di Bernoulli, con due possibili uscite testa, \(X=0\), o croce, \(X=1\). La forma generale della distribuzione di probabilità di una variabile casuale di Bernoulli \(B(p)\) è
\begin{equation*}
\begin{split}p(X) = \begin{cases} p & , \quad X = H:\text{Head} \\ 1-p & , \quad X = T:\text{Tail} \end{cases} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
essendo \(p \in [0,1]\) la probabilità associata al valore \(X=H\) e \(1-p\) quella associata al valore \(X=T\).

\sphinxAtStartPar
Per la verifica dell’ipotesi si organizza una campagna sperimentale di \(n\) lanci e si sceglie come \sphinxstylestrong{statistica test} \(x\) il numero di volte che il risultato del lancio è testa, \(X=H\).
Per una variabile casuale con distribuzione di probabilità di Bernoulli \(B(p)\), il numero \(x\) di risultati \(X=H\) in \(n\) ripetizioni indipendenti dell’evento è a sua volta una variabile casuale, con distribuzione di probabilità binomiale \(\mathscr{B}(n,p)\)
\begin{equation*}
\begin{split}p_n(x) = \left( \begin{matrix} n \\ x \end{matrix}  \right) \, p^x \, (1-p)^{n-x}\end{split}
\end{equation*}

\subparagraph{Import librerie}
\label{\detokenize{ch/statistics/test-fisher-coin-1:import-librerie}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import libraries}
\PYG{o}{\PYGZpc{}}\PYG{k}{reset} \PYGZhy{}f
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy} \PYG{k}{as} \PYG{n+nn}{sp}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subparagraph{Campione generato dal processo casuale}
\label{\detokenize{ch/statistics/test-fisher-coin-1:campione-generato-dal-processo-casuale}}
\sphinxAtStartPar
Viene lanciata una moneta \(n_{flips}\) volte. Dati

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Random process of interest, unknown execpt for the sample.}
\PYG{n}{p\PYGZus{}head} \PYG{o}{=} \PYG{l+m+mf}{.5}
\PYG{n}{p\PYGZus{}tail} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{p\PYGZus{}head}

\PYG{c+c1}{\PYGZsh{} Coin flip as a Bernoulli probability with outcomes: a = [0, 1] with prob p = [p\PYGZus{}head, p\PYGZus{}tail]}
\PYG{n}{flip\PYGZus{}rng} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{default\PYGZus{}rng}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{o}{.}\PYG{n}{choice}
\PYG{n}{n\PYGZus{}flips} \PYG{o}{=} \PYG{l+m+mi}{30}
\PYG{n}{flip\PYGZus{}params} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{p\PYGZus{}head}\PYG{p}{,} \PYG{n}{p\PYGZus{}tail}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{n\PYGZus{}flips} \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Running coin flip experiment}
\PYG{n}{ov} \PYG{o}{=} \PYG{n}{flip\PYGZus{}rng}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{flip\PYGZus{}params}\PYG{p}{)}

\PYG{n}{coin\PYGZus{}dict} \PYG{o}{=} \PYG{p}{[} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{head}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tail}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} print([ coin\PYGZus{}dict[o] for o in ov])}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZgt{} Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n.samples: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}flips}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{heads:tails }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{ov}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{:}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}flips}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{ov}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{} Experiment
n.samples: 30
heads:tails 17:13
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ! Approach for low\PYGZhy{}dimensional problems, with no memory or performance issues}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Null hypotesis, H0: the coin is fair}
\PYG{c+c1}{\PYGZsh{} The outcome of a single flip is a r.v. distributed like a Bernoulli variable with p\PYGZus{}head = .5}
\PYG{c+c1}{\PYGZsh{} Every flip is statistically independent from the other}
\PYG{n}{ixv} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{n\PYGZus{}flips}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{xv} \PYG{o}{=} \PYG{n}{ixv} \PYG{o}{/} \PYG{n}{n\PYGZus{}flips}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Test statistics: average n.of heads in flip\PYGZus{}n samples}
\PYG{c+c1}{\PYGZsh{} H0 hypotesis implies that the outcome of flip\PYGZus{}n is a r.v. with Binomial pdf}
\PYG{n}{x\PYGZus{}H0\PYGZus{}fv} \PYG{o}{=} \PYG{n}{sp}\PYG{o}{.}\PYG{n}{stats}\PYG{o}{.}\PYG{n}{binom}\PYG{o}{.}\PYG{n}{pmf}\PYG{p}{(}\PYG{n}{ixv}\PYG{p}{,} \PYG{n}{n\PYGZus{}flips}\PYG{p}{,} \PYG{n}{p\PYGZus{}head}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Test characteristics: symmetric}
\PYG{n}{test\PYGZus{}type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{value}\PYG{l+s+s1}{\PYGZsq{}}  \PYG{c+c1}{\PYGZsh{} \PYGZsq{}symmetric\PYGZsq{}, \PYGZsq{}right\PYGZsq{}, \PYGZsq{}left\PYGZsq{}, \PYGZsq{}value\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Significance level, alpha = .05 (\PYGZdq{}default\PYGZdq{})}
\PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{.05}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Acceptance and rejection regions, for discrete pdf}
\PYG{c+c1}{\PYGZsh{} Starting from the value of the test statistics x\PYGZus{}max = max(x\PYGZus{}H0\PYGZus{}fv), expand }

\PYG{k}{def} \PYG{n+nf}{find\PYGZus{}acceptance\PYGZus{}region}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{,} \PYG{n}{test\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Find acceptance region for a discrete pdf, supposed to be unimodal \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{ix\PYGZus{}max} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{argmax}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
    \PYG{n}{nx} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}
    \PYG{n}{threshold} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}

    \PYG{c+c1}{\PYGZsh{} Initialization}
    \PYG{n}{p\PYGZus{}acc}\PYG{p}{,} \PYG{n}{ixl}\PYG{p}{,} \PYG{n}{ixr} \PYG{o}{=} \PYG{n}{p}\PYG{p}{[}\PYG{n}{ix\PYGZus{}max}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ix\PYGZus{}max}\PYG{p}{,} \PYG{n}{ix\PYGZus{}max}
    
    \PYG{c+c1}{\PYGZsh{} if ( test\PYGZus{}type == \PYGZsq{}value\PYGZsq{} ):}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{p\PYGZus{}acc} \PYG{o}{\PYGZlt{}} \PYG{n}{threshold} \PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{p}{(} \PYG{n}{p}\PYG{p}{[}\PYG{n}{ixl}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{p}\PYG{p}{[}\PYG{n}{ixr}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{)}\PYG{p}{:}
            \PYG{n}{ixl} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}  \PYG{n}{p\PYGZus{}acc} \PYG{o}{+}\PYG{o}{=} \PYG{n}{p}\PYG{p}{[}\PYG{n}{ixl}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{ixr} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}  \PYG{n}{p\PYGZus{}acc} \PYG{o}{+}\PYG{o}{=} \PYG{n}{p}\PYG{p}{[}\PYG{n}{ixr}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} else:}
    \PYG{k}{return} \PYG{n}{ixl}\PYG{p}{,} \PYG{n}{ixr}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Compute acceptance region}
\PYG{n}{ixl}\PYG{p}{,} \PYG{n}{ixr} \PYG{o}{=} \PYG{n}{find\PYGZus{}acceptance\PYGZus{}region}\PYG{p}{(}\PYG{n}{x\PYGZus{}H0\PYGZus{}fv}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{,}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate test statistics on the samples}
\PYG{n}{ixs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{ov}\PYG{p}{)}
\PYG{n}{xs}  \PYG{o}{=} \PYG{n}{ixs} \PYG{o}{/} \PYG{n}{n\PYGZus{}flips}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Compare test statistics on the samples with the acceptance region}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{ixl} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{ixs} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{ixr} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H0 accepted}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H0 rejected}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{ix\PYGZus{}acc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{ixl}\PYG{p}{,} \PYG{n}{ixr}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{x\PYGZus{}acc} \PYG{o}{=} \PYG{n}{xv}\PYG{p}{[}\PYG{n}{ix\PYGZus{}acc}\PYG{p}{]}

\PYG{n}{dx\PYGZus{}bar} \PYG{o}{=} \PYG{p}{(}\PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{xv}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{.90}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}   \PYG{n}{xv}\PYG{p}{,} \PYG{n}{x\PYGZus{}H0\PYGZus{}fv}        \PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{dx\PYGZus{}bar}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}\PYG{n}{x\PYGZus{}acc}\PYG{p}{,} \PYG{n}{x\PYGZus{}H0\PYGZus{}fv}\PYG{p}{[}\PYG{n}{ix\PYGZus{}acc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{dx\PYGZus{}bar}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{bar}\PYG{p}{(}   \PYG{n}{xs}\PYG{p}{,} \PYG{n}{x\PYGZus{}H0\PYGZus{}fv}\PYG{p}{[}\PYG{n}{ixs}\PYG{p}{]}   \PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{n}{dx\PYGZus{}bar}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} print(xv)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
H0 accepted
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}BarContainer object of 1 artists\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{011f32f8b4551cb3cc9cbbf6a5356b4616fc8f3233b4e14cca59515734a02b27}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\subsubsection{Moneta truccata}
\label{\detokenize{ch/statistics/test-fisher-coin-2:moneta-truccata}}\label{\detokenize{ch/statistics/test-fisher-coin-2::doc}}
\sphinxAtStartPar
Si vuole valutare se una moneta è truccata. L’ipotesi nulla \(\text{H}_0\) da falsificare è «la moneta non è truccata». Si sceglie come statistica test la percentuale di risultati «testa» sul numero di lanci.

\sphinxAtStartPar
L’esperimento viene condotto per un numero incrementale di esperimenti.


\paragraph{Import librerie e funzioni utili}
\label{\detokenize{ch/statistics/test-fisher-coin-2:import-librerie-e-funzioni-utili}}

\subparagraph{Import librerie}
\label{\detokenize{ch/statistics/test-fisher-coin-2:import-librerie}}
\sphinxAtStartPar
Reset delle variabili e import librerie.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{Funzione per lo svolgimento di un esperimento}
\label{\detokenize{ch/statistics/test-fisher-coin-2:funzione-per-lo-svolgimento-di-un-esperimento}}
\sphinxAtStartPar
La funzione per lo svolgimento di un esperimento qui definita prende come argomenti un generatore di numeri casuali e i suoi parametri, e restituisce i campioni prodotti secondo la distribuzione data. Vengono definiti dei parametri di default, corrispondenti a una distribuzione di Bernoulli uniforme

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subparagraph{Funzione che restituisce la pdf \protect\(p(x|\text{H}_0)\protect\)}
\label{\detokenize{ch/statistics/test-fisher-coin-2:funzione-che-restituisce-la-pdf-p-x-text-h-0}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subparagraph{Funzioni per la ricerca degli intervalli di accettazione dell’ipotesi}
\label{\detokenize{ch/statistics/test-fisher-coin-2:funzioni-per-la-ricerca-degli-intervalli-di-accettazione-dell-ipotesi}}
\sphinxAtStartPar
Vengono qui definite due funzoni per la ricerca degli intervalli di accettazione, dato il livello di significatività del test richiesto. La prima funzione ricerca un unico intervallo di accettazione riferito a un unico livello di significatività; la seconda funzione ricerca tanti intervalli di accettazione quanti sono i livelli di significatività cercati: ad esempio, si possono cercare simultaneamente i livellidi significatività associati a \(\sigma\), \(2 \sigma\), \(3 \sigma\)…

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{Esperimento}
\label{\detokenize{ch/statistics/test-fisher-coin-2:esperimento}}

\subparagraph{Livelli di accettazione}
\label{\detokenize{ch/statistics/test-fisher-coin-2:livelli-di-accettazione}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subparagraph{Svolgimento esperimento}
\label{\detokenize{ch/statistics/test-fisher-coin-2:svolgimento-esperimento}}
\sphinxAtStartPar
L’esperimento viene svolto usando due monete, la cui natura è a priori incognita, che possono essere modellate con variabili casuali di Bernoulli: una moneta non truccata produce testa o croce con la probaiblità uniforme \(0.5\); una moneta truccata che produce testa o croce con probabilità \(0.45 - 0.55\)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/home/davide/.local/lib/python3.8/site\PYGZhy{}packages/scipy/stats/\PYGZus{}discrete\PYGZus{}distns.py:77: RuntimeWarning: divide by zero encountered in \PYGZus{}binom\PYGZus{}pdf
  return \PYGZus{}boost.\PYGZus{}binom\PYGZus{}pdf(x, n, p)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subparagraph{Grafici}
\label{\detokenize{ch/statistics/test-fisher-coin-2:grafici}}
\sphinxAtStartPar
Il valore medio delle volte che è uscita croce viene usata come statistica test. Il valore della statistica test per gli esperimenti condotti con le due monete viene confrontato con la funzione di distribuzione \(p(x|\text{H}_0)\) per una moneta non truccata. Viene mostrato l’andamento delle statistiche test e degli intervalli di accettazione in funzione del numero di lanci della moneta. Vengono mostrati i dati raccolti e successivamente depurati della media attesa e scalati per la varianza della media campionaria \(\frac{\sigma}{\sqrt{n_s}}\), per mettere in evidenza i livelli di significatività \([0.3, 0.05, 0.003]\)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}matplotlib.legend.Legend at 0x7fbbde492b80\PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{8c8d72668c9df4ed9ed9b8c8783f6b69e5e6d0b5299698bf4f208e42da672d4d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\subsubsection{Gambler rabbit}
\label{\detokenize{ch/statistics/test-fisher-rabbit:gambler-rabbit}}\label{\detokenize{ch/statistics/test-fisher-rabbit::doc}}
\sphinxstepscope


\subsubsection{\protect\(t\protect\)\sphinxhyphen{}test}
\label{\detokenize{ch/statistics/t-test:t-test}}\label{\detokenize{ch/statistics/t-test::doc}}


\sphinxAtStartPar
Un \(t\)\sphinxhyphen{}test è un test di verifica delle ipotesi nel quale la \sphinxstylestrong{statistica test} ha una distribuzione \sphinxstylestrong{\(\mathbf{t}\) di Student} sotto l’ipotesi nulla \(\text{H}_0\),
\begin{equation*}
\begin{split}p(x|\text{H}_0) \sim t_{\nu}\end{split}
\end{equation*}

\paragraph{\protect\(t\protect\)\sphinxhyphen{}test per un campione}
\label{\detokenize{ch/statistics/t-test:t-test-per-un-campione}}
\sphinxAtStartPar
Il \(t\)\sphinxhyphen{}test per un campione è un test di verifica del valore di un parametro, per la media di una variabile casuale sotto un’opportuna ipotesi nulla \(\text{H}_0\). Il parametro \(t\),
\begin{equation*}
\begin{split}t = \frac{\hat{x} - \mu_0}{\frac{\hat{s}}{\sqrt{n}}} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
confronta la distanza della media \(\bar{x}\) del campione dal valore medio \(\mu_0\) della distribuzione \(p(x|\text{H}_0)\), con la deviazione standard del campione \(s\) opportunamente scalata della grandezza del campione \(n\).

\sphinxAtStartPar
Se le osservazioni della variabile casuale sono indipdendenti tra di loro, allora \(t\) è una variabile casuale che tende a una variabile normale \(\mathscr{N}(0,1)\) per il teorema del limite centrale \sphinxstylestrong{todo} \sphinxstyleemphasis{link a una sezione sul campionamento}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Example}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{stats} \PYG{k+kn}{import} \PYG{n}{ttest\PYGZus{}1samp}\PYG{p}{,} \PYG{n}{t}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{c+c1}{\PYGZsh{} Test statistics has expected value mu0 under H0 hypotesis}
\PYG{n}{mu0} \PYG{o}{=} \PYG{l+m+mf}{86.}          \PYG{c+c1}{\PYGZsh{} Expeceted value of the test statistics under H0}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.05}       \PYG{c+c1}{\PYGZsh{} Significance level}


\PYG{c+c1}{\PYGZsh{} Sample data: test scores from two classes}
\PYG{n}{sample} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{92}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{87}\PYG{p}{]}
\PYG{n}{n\PYGZus{}s} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}
\PYG{n}{mu\PYGZus{}s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{)}\PYG{o}{/}\PYG{n}{n\PYGZus{}s}
\PYG{n}{s\PYGZus{}s} \PYG{o}{=} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sample}\PYG{o}{\PYGZhy{}}\PYG{n}{mu\PYGZus{}s}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{n\PYGZus{}s}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{.5}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sample statistics:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample avg    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mu\PYGZus{}s}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample std.dev: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{s\PYGZus{}s}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Perform independent t\PYGZhy{}test}
\PYG{n}{t\PYGZus{}statistic}\PYG{p}{,} \PYG{n}{p\PYGZus{}value} \PYG{o}{=} \PYG{n}{ttest\PYGZus{}1samp}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{mu0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{1\PYGZhy{}sample t\PYGZhy{}test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ t\PYGZhy{}Statistic: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t\PYGZus{}statistic}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ p\PYGZhy{}Value    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{p\PYGZus{}value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Interpretation}
\PYG{k}{if} \PYG{n}{p\PYGZus{}value} \PYG{o}{\PYGZlt{}} \PYG{n}{sigma}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZgt{} Reject the null hypothesis, H0: the means of the two classes are significantly different.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZgt{} Fail to reject the null hypothesis, H0: no significant difference in means between the classes.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{x\PYGZus{}plot} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mf}{.01}\PYG{p}{)}
\PYG{n}{t\PYGZus{}pdf\PYGZus{}plot} \PYG{o}{=} \PYG{n}{t}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{n\PYGZus{}s}\PYG{p}{,} \PYG{n}{mu\PYGZus{}s}\PYG{p}{,} \PYG{n}{s\PYGZus{}s}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{t\PYGZus{}pdf\PYGZus{}plot}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{sample}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{n\PYGZus{}s}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mu\PYGZus{}s}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{markeredgewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mu0} \PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}        \PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{markeredgewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sample statistics:
 sample avg    : 88.6
 sample std.dev: 2.8809720581775866

1\PYGZhy{}sample t\PYGZhy{}test
 t\PYGZhy{}Statistic: 2.017991366836461
 p\PYGZhy{}Value    : 0.11375780482862627

\PYGZgt{} Fail to reject the null hypothesis, H0: no significant difference in means between the classes.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x7f65f004a910\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{b447209d18774c554d77059adc27f1afcb900a0a10e8e9db17f5ca0f6304b8c4}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\paragraph{\protect\(t\protect\)\sphinxhyphen{}test per due campioni}
\label{\detokenize{ch/statistics/t-test:t-test-per-due-campioni}}\begin{itemize}
\item {} 
\sphinxAtStartPar
test con varianza uguale (o simile), \sphinxstyleemphasis{t}\sphinxhyphen{}test/test con varianza diversa, \sphinxstyleemphasis{Welch}

\item {} 
\sphinxAtStartPar
campioni indipendenti/campioni dipendenti (paired samples)

\end{itemize}


\subparagraph{\protect\(t\protect\)\sphinxhyphen{}test per due variabili indipendenti, con varianza simile e stesso numero di osservazioni}
\label{\detokenize{ch/statistics/t-test:t-test-per-due-variabili-indipendenti-con-varianza-simile-e-stesso-numero-di-osservazioni}}
\sphinxAtStartPar
Nell’ipotesi che i campioni siano ottenuti da due variabili indipendenti, i risultati ottenuti nella sezione sulla {\hyperref[\detokenize{ch/statistics::doc}]{\sphinxcrossref{\DUrole{doc,std,std-doc}{combinazione di variabili casuali}}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
il \sphinxstylestrong{valore atteso} della somma/differenza di variabili casuali indipendenti è uguale alla somma/differenza dei valori attesi delle singole variabili

\item {} 
\sphinxAtStartPar
la \sphinxstylestrong{varianza} della somma/differenza di variabili casuali indipendenti è uguale alla somma delle varianze delle singole variabili.

\end{itemize}

\sphinxAtStartPar
Il \(t\)\sphinxhyphen{}test per due campioni equivale al \(t\)\sphinxhyphen{}test per un campione uguale alla differenza delle osservazioni nei due campioni,
\begin{equation*}
\begin{split}z_i = x_i - y_i \ .\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Example}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{stats} \PYG{k+kn}{import} \PYG{n}{ttest\PYGZus{}ind}

\PYG{c+c1}{\PYGZsh{} Significance level}
\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.05}

\PYG{c+c1}{\PYGZsh{} Sample data: test scores from two classes}
\PYG{n}{class\PYGZus{}A} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{92}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{87}\PYG{p}{]}
\PYG{n}{class\PYGZus{}B} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{78}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{83}\PYG{p}{,} \PYG{l+m+mi}{79}\PYG{p}{]}

\PYG{n}{nA} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{class\PYGZus{}A}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mu\PYGZus{}A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{class\PYGZus{}A}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nA}\PYG{p}{;} \PYG{n}{sA} \PYG{o}{=} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{class\PYGZus{}A}\PYG{o}{\PYGZhy{}}\PYG{n}{mu\PYGZus{}A}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nA}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{.5}
\PYG{n}{nB} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{class\PYGZus{}B}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mu\PYGZus{}B} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{class\PYGZus{}B}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nB}\PYG{p}{;} \PYG{n}{sB} \PYG{o}{=} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{class\PYGZus{}B}\PYG{o}{\PYGZhy{}}\PYG{n}{mu\PYGZus{}B}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{nB}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{.5}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sample statistics:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sample A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample avg    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mu\PYGZus{}A}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample std.dev: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sA}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sample B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample avg    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mu\PYGZus{}B}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ sample std.dev: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sB}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Perform independent t\PYGZhy{}test}
\PYG{n}{t\PYGZus{}statistic}\PYG{p}{,} \PYG{n}{p\PYGZus{}value} \PYG{o}{=} \PYG{n}{ttest\PYGZus{}ind}\PYG{p}{(}\PYG{n}{class\PYGZus{}A}\PYG{p}{,} \PYG{n}{class\PYGZus{}B}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{s\PYGZhy{}sample t\PYGZhy{}test}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ t\PYGZhy{}Statistic: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{t\PYGZus{}statistic}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ p\PYGZhy{}Value    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{p\PYGZus{}value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{mu\PYGZus{}A}\PYG{o}{\PYGZhy{}}\PYG{n}{mu\PYGZus{}B}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sA}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{sB}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nA}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Interpretation}
\PYG{k}{if} \PYG{n}{p\PYGZus{}value} \PYG{o}{\PYGZlt{}} \PYG{n}{sigma}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Reject the null hypothesis: The means of the two classes are significantly different.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Fail to reject the null hypothesis: No significant difference in means between the classes.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{x\PYGZus{}plot} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mf}{.01}\PYG{p}{)}
\PYG{n}{t\PYGZus{}pdf\PYGZus{}A} \PYG{o}{=} \PYG{n}{t}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{nA}\PYG{p}{,} \PYG{n}{mu\PYGZus{}A}\PYG{p}{,} \PYG{n}{sA}\PYG{p}{)}
\PYG{n}{t\PYGZus{}pdf\PYGZus{}B} \PYG{o}{=} \PYG{n}{t}\PYG{o}{.}\PYG{n}{pdf}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{nB}\PYG{p}{,} \PYG{n}{mu\PYGZus{}B}\PYG{p}{,} \PYG{n}{sB}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{t\PYGZus{}pdf\PYGZus{}A}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x\PYGZus{}plot}\PYG{p}{,} \PYG{n}{t\PYGZus{}pdf\PYGZus{}B}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{class\PYGZus{}A}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{nA}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{class\PYGZus{}B}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n}{nB}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}       \PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mu\PYGZus{}A}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{tab10}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{markeredgewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mu\PYGZus{}B}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orange}\PYG{l+s+s1}{\PYGZsq{}}       \PYG{p}{,} \PYG{n}{markersize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{markeredgewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sample statistics:
Sample A
 sample avg    : 88.6
 sample std.dev: 2.8809720581775866
Sample B
 sample avg    : 81.0
 sample std.dev: 2.9154759474226504

s\PYGZhy{}sample t\PYGZhy{}test
 t\PYGZhy{}Statistic: 4.146139914483853
 p\PYGZhy{}Value    : 0.0032260379191180397
4.146139914483853

Reject the null hypothesis: The means of the two classes are significantly different.
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZlt{}matplotlib.lines.Line2D at 0x7f65efee6dc0\PYGZgt{}]
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{ad9e0a740f0f409ab9699cc4cac6809aff9c408ab244bacfcd1a9c9e8e4c1ab3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxstepscope


\subsubsection{Regressione lineare}
\label{\detokenize{ch/statistics/linear_regression:regressione-lineare}}\label{\detokenize{ch/statistics/linear_regression:statistics-hs-linear-regression}}\label{\detokenize{ch/statistics/linear_regression::doc}}
\sphinxAtStartPar
Nella sua forma elementare, la regressione lineare è un’approssimazione (stimatore) lineare
\begin{equation*}
\begin{split}\hat{Y}(X|\theta) = a X + b \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
tra una coppia di campioni \(\{ X_n \}_{n=1:N}\), \(\{ Y_n \}_{n=1:N}\) estratti dalle popolazioni \(X\), \(Y\), i cui parametri \(\theta = (a,b)\) rendono minimo l’errore quadratico medio
\begin{equation*}
\begin{split}e:= \sum_{n=1}^{N} ( \hat{y}(X_n) - Y_n )^2 = \sum_{n=1}^N ( a \, X_n + b - Y_n )^2 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
il cui valore permette di stimare la significatività dell’approssimazione lineare.
\subsubsection*{Algoritmo}

\sphinxAtStartPar
L’algoritmo base consiste nella:
\begin{itemize}
\item {} 
\sphinxAtStartPar
normalizzazione dei campioni:
\begin{itemize}
\item {} 
\sphinxAtStartPar
vengono calcolate le medie e le varianze campionarie
\begin{equation*}
\begin{split}\begin{aligned}
      \mu_x = \frac{1}{N} \sum_{n=1}^N X_n \qquad & , \qquad S^2_x = \frac{1}{N-1} (X_n - \mu_x)^2 \\
      \mu_y = \frac{1}{N} \sum_{n=1}^N Y_n \qquad & , \qquad S^2_y = \frac{1}{N-1} (Y_n - \mu_y)^2
    \end{aligned}\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
vengono definiti i campioni normalizzati
\begin{equation*}
\begin{split}x_n = \frac{X_n - \mu_x}{S_x} \qquad , \qquad y_n = \frac{Y_n - \mu_y}{S_y}\end{split}
\end{equation*}
\sphinxAtStartPar
che hanno media nulla e varianza campionaria unitaria.

\end{itemize}

\item {} 
\sphinxAtStartPar
calcolo dei valori ottimi dei parametri \(\theta = (a, b)\) del modello applicato ai dati scalati,
\begin{equation*}
\begin{split}\hat{y}(x|\theta) = a x + b\end{split}
\end{equation*}
\sphinxAtStartPar
che rendono minimo l’errore quadratico,
\begin{equation*}
\begin{split}e:= \sum_{n=1}^{N} ( \hat{y}(x_n) - y_n )^2 = \sum_{n=1}^N ( a \, x_n + b - y_n )^2 \ .\end{split}
\end{equation*}
\sphinxAtStartPar
L’errore quadratico è una funzione definita positiva con un unico minimo in corrispondenza del sistema lineare formato dalle condizioni di derivate parziali nulle,
\begin{equation*}
\begin{split}\begin{cases}
     0 & = \dfrac{\partial e}{\partial a} = 2 \sum_{n=1}^N ( a \, x_n + b - y_n ) x_n \\
     0 & = \dfrac{\partial e}{\partial b} = 2 \sum_{n=1}^N ( a \, x_n + b - y_n )     \\
   \end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
che ha forma diagonale e, introducendo il coefficiente di correlazione dei campioni,
\begin{equation*}
\begin{split}r^2_{XY} = \frac{S^2_XY}{S_X S_Y} \qquad , \qquad S^2_{XY} = \frac{1}{N-1} \sum_{n=1}^N (X_n - \mu_X)(Y_n - \mu_Y) \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e usando il fomralismo matriciale può essere riscritto come,
\begin{equation*}
\begin{split}\begin{bmatrix} N-1 & 0 \\ 0 & N \end{bmatrix} \begin{bmatrix} a \\ b \end{bmatrix} = \begin{bmatrix} (N-1) r_{XY} \\ 0 \end{bmatrix} \ ,
   \end{split}
\end{equation*}
\sphinxAtStartPar
la cui soluzione è \(a^* = r_{XY}\), \(b^* = 0\). La forma della regressione lineare in termini delle variabili normalizzate è
\begin{equation*}
\begin{split}\hat{y}(x) = r_{XY} x \ .\end{split}
\end{equation*}
\sphinxAtStartPar
L’errore quadratico minimo nelle variabili normalizzate vale
\begin{equation*}
\begin{split}\begin{aligned}
     e^* & = \sum_{n=1}^N ( a^* x_n + b^* - y_n )^2 = \\
         & = \sum_{n=1}^N ( r_{XY} x_n - y_n )^2 = \\
         & = r^2_{XY} (N-1) - 2 (N-1) r_{XY} r_{XY} + (N-1) = \\
         & = (N-1) \left( 1 - r^2_{XY} \right) \ .
   \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
Il modello nelle variabili originali diventa
\begin{equation*}
\begin{split}\begin{aligned}
     \hat{Y}(X) & = \mu_Y + S_Y r_{XY} \frac{X - \mu_X}{S_X} = \\
                & = r_{XY} \frac{S_Y}{S_X} X + \mu_Y - \mu_X r_{XY} \frac{S_Y}{S_X} = \\
                & = \frac{S^2_{XY}}{S^2_X} X + \mu_Y - \mu_X \frac{S^2_{XY}}{S^2_X} 
   \end{aligned}\end{split}
\end{equation*}
\end{itemize}
\subsubsection*{Regressione lineare come MLE}

\sphinxAtStartPar
La regressione lineare può essere interpretata come risultato di un metodo di Maximum Likelihood Estimation, supponendo che ogni osservazione \(y_n\) sia il risultato del modello lineare lineare \(a x_n + b\) con l’aggiunta di un errore \(\varepsilon_n\),
\begin{equation*}
\begin{split}y_n = a x_n + b + \varepsilon_n \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
di variabili gaussiane indipendenti non correlate, identicamente distribuite a media nulla e varianza \(\sigma^2\),
\begin{equation*}
\begin{split}\varepsilon_n \sim \mathscr{N}(0, \sigma^2) \sim \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left[ - \frac{x^2}{2 \sigma^2} \right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\mathbb{E}[\varepsilon_m \varepsilon_n] = \sigma^2 \delta_{mn} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Assumendo le \(x_n\), \(a\), \(b\) osservazioni e parametri deterministici, senza incertezza, segue che
\begin{equation*}
\begin{split}y_n \sim \mathscr{N}(a x_n + b, \sigma^2) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
I parametri ottimi del modello \(a\), \(b\), \(\sigma^2\) rendono massima la probabilità,
\begin{equation*}
\begin{split}p(\mathbf{x},\mathbf{y}|\theta) = \prod_{n=1}^N \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left[ -\frac{(a x_n + b - y_n)^2}{2\sigma^2} \frac{}{} \right] \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
nel caso in cui le osservazioni siano indipendenti e quindi valga \(p(\mathbf{x},\mathbf{y}|\theta) = \prod_{n=1}^N p(x_n,y_n|\theta)\), o il suo logaritmo
\begin{equation*}
\begin{split}\ln p(\mathbf{x},\mathbf{y}|\theta) = - \frac{N}{2} \ln (2\pi \sigma^2) - \sum_{n=1}^N \frac{(a x_n + b - y_n)^2}{2 \sigma^2} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
L’annullamento delle derivate parziali produce il sistema lineare
\begin{equation*}
\begin{split}\begin{cases}
 0 & = \frac{\partial p}{\partial a}        = \sum_{n=1}^N ( a x_n + b - y_n ) x_n \\
 0 & = \frac{\partial p}{\partial b}        = \sum_{n=1}^N ( a x_n + b - y_n ) \\
 0 & = \frac{\partial p}{\partial \sigma^2} = -\frac{N}{2}\frac{1}{\sigma^2} + \sum_{n=1}^N \frac{( a x_n + b - y_n )^2}{2 \sigma^4} \\
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
la cui soluzione, ipotizzando di aver normalizzato i campioni sulle medie e varianze campionarie,
\begin{equation*}
\begin{split}\begin{aligned}
  a^* = r_{XY} \quad , \quad b^* = 0 \quad , \quad \sigma^{2*} = \frac{1}{N} \sum_{n=1}^N \left( a x_n + b - y_n  \right)^2 = \frac{e^*}{N} = \frac{N-1}{N} (1 - r^2_{XY})
\end{aligned}\end{split}
\end{equation*}\subsubsection*{Statistiche \protect\(\ \chi^2 \ \protect\) e \protect\(\ t \ \protect\)}

\sphinxAtStartPar
Siano \(y_n\) delle variabili gaussiane con varianza \(\sigma^2\) e media \(a x_n + b\), con \(b = 0\) e
\begin{equation*}
\begin{split}\begin{aligned}
  a = r
    & = \frac{S^2_{XY}}{S_X S_Y} = \\
    & = \frac{\frac{1}{N-1} \sum_{n=1}^{N} (X_n - \bar{X})(Y_n - \bar{Y})}{\sqrt{\frac{1}{N-1} \sum_{n=1}^{N} (X_n - \bar{X})^2} \sqrt{\frac{1}{N-1} \sum_{n=1}^{N} (Y_n - \bar{Y})^2}} = \\
    & = \frac{1}{N-1} \sum_{n=1}^N \left( \frac{X_n - \bar{X}}{S_X} \right)  \left(  \frac{Y_n - \bar{Y}}{S_Y} \right) = \\
    & = \frac{1}{N-1} \sum_{n=1}^N x_n \, y_n 
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\mathbb{E}[a] = \frac{1}{N-1} \sum_{m=1}^{N} x_m \mathbb{E}[y_m]\end{split}
\end{equation*}\begin{equation*}
\begin{split}\varepsilon_n := y_n - a x_n \sim \mathscr{N}(0, \sigma^2) \ .\end{split}
\end{equation*}\begin{equation*}
\begin{split}0 = \mathbb{E}[\varepsilon_n] = \mathbb{E}[y_n] - \mathbb{E}[a] \, x_n\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned}
  \sigma^2 \delta_{mn}
  & = \mathbb{E}\left[ \varepsilon_m \varepsilon_n \right] = \\
  & = \mathbb{E}\left[ (y_m - a x_m) (y_n - a x_n) \right] = \\
  & = \mathbb{E}\left[ y_m y_n \right] - x_m \mathbb{E} \left[ a y_n \right] -  y_m \mathbb{E} \left[ a x_n \right] + x_n \, x_m \mathbb{E}[ a^2 ] = \\
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned}
  \mathbb{E}[y_m y_n] 
  & = \mathbb{E}[ (\bar{y}_m + \delta y_m) ( \bar{y}_n + \delta y_n )] = \\
  & = \bar{y}_m \bar{y}_n + \mathbb{E}[ \delta y_m \delta y_n ] = \\
  & = \bar{y}_m \bar{y}_n + \sigma^2 \delta_{mn} \\
\end{aligned}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{aligned}
  \mathbb{E}\left[ \sum_{n=1}^{N} (y_n - a x_n)^2 \right] 
  & = \mathbb{E}\left[ \sum_{n=1}^{N} \left(y_n - \frac{1}{N-1} \sum_{m=1}^N y_m x_m x_n \right)^2 \right] = \\
  & = \sum_{n=1}^{N} \mathbb{E}\left[ y^2_n - \frac{2}{N-1} \sum_{m=1}^{N} y_n y_m x_m x_n + \frac{2}{(N-1)^2} \sum_{m=1}^{N} \sum_{p > m} y_m y_p x_m x_p x_n^2 + \frac{1}{(N-1)^2} \sum_{m=1}^{N} y_m^2 x_m^2 x_n^2 \right] = \\
  & = \sum_{n=1}^{N} ( \bar{y}_n^2 + \sigma^2 ) - \frac{2}{N-1} \sum_{n,m=1}^N (\bar{y}_m \bar{y}_n + \sigma^2 \delta_{mn}) x_m x_n + \frac{2}{(N-1)^2} \sum_{n,m=1}^N \sum_{p>m} (\bar{y}_m \bar{y}_p + \sigma^2 \delta_{mp}) x_m x_p x_n^2 + \frac{1}{(N-1)^2} \sum_{n,m=1}^N \left( \bar{y}_m^2 + \sigma^2 \right) x_m^2 x_n^2   = \\
  & = \bar{a}^2 \sum_{n=1}^N x_n^2 + N \sigma^2 - \frac{2 \bar{a}^2}{N-1} \sum_{m,n=1}^{N} x_m^2 x_n^2 - \frac{2}{N-1} \sigma^2\sum_{n=1}^{N} x_n^2 + \\
  & \quad + \frac{2}{(N-1)^2} \sum_{n,m=1}^{N} \sum_{p>m} x_m^2 x_p^2 x_n^2 + \frac{\bar{a}^2}{(N-1)^2} \sum_{m,n=1}^N x_m^4 x_n^2 + \frac{1}{(N-1)^2} \sigma^2 \sum_{m,n=1}^{N} x_m^2 x_n^2 = \\
  & = \bar{a}^2 (N-1) + N \sigma^2 - 2 \bar{a}^2 (N-1) - 2 \sigma^2 + 2 \sum_{p \dots} \dots + \dots \bar{a}^2 \sum_{\dots} x_m^4 + \sigma^2
\end{aligned}\end{split}
\end{equation*}
\sphinxstepscope


\subsubsection{ANOVA \sphinxhyphen{} Analysis of variance}
\label{\detokenize{ch/statistics/anova:anova-analysis-of-variance}}\label{\detokenize{ch/statistics/anova::doc}}

\paragraph{Metodo}
\label{\detokenize{ch/statistics/anova:metodo}}

\paragraph{Esempio}
\label{\detokenize{ch/statistics/anova:esempio}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} ANOVA \PYGZhy{} Analysis of variance}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{stats} \PYG{k+kn}{import} \PYG{n}{f\PYGZus{}oneway}

\PYG{c+c1}{\PYGZsh{} Sample data: test scores from three teaching methods}
\PYG{n}{method\PYGZus{}A} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{92}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{87}\PYG{p}{]}
\PYG{n}{method\PYGZus{}B} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{78}\PYG{p}{,} \PYG{l+m+mi}{85}\PYG{p}{,} \PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{83}\PYG{p}{,} \PYG{l+m+mi}{79}\PYG{p}{]}
\PYG{n}{method\PYGZus{}C} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{94}\PYG{p}{,} \PYG{l+m+mi}{89}\PYG{p}{,} \PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{96}\PYG{p}{,} \PYG{l+m+mi}{90}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Perform one\PYGZhy{}way ANOVA}
\PYG{n}{f\PYGZus{}statistic}\PYG{p}{,} \PYG{n}{p\PYGZus{}value} \PYG{o}{=} \PYG{n}{f\PYGZus{}oneway}\PYG{p}{(}\PYG{n}{method\PYGZus{}A}\PYG{p}{,} \PYG{n}{method\PYGZus{}B}\PYG{p}{,} \PYG{n}{method\PYGZus{}C}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Display results}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{F\PYGZhy{}Statistic: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f\PYGZus{}statistic}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{P\PYGZhy{}Value: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{p\PYGZus{}value}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Interpretation}
\PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.05}
\PYG{k}{if} \PYG{n}{p\PYGZus{}value} \PYG{o}{\PYGZlt{}} \PYG{n}{alpha}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Reject the null hypothesis: There is a significant difference between the groups.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fail to reject the null hypothesis: No significant difference between the groups.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
F\PYGZhy{}Statistic: 18.806324110671927
P\PYGZhy{}Value: 0.00020023178541394456
Reject the null hypothesis: There is a significant difference between the groups.
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Introduzione ai metodi in statistica e  AI}

\sphinxstepscope


\chapter{Introduzione ai metodi in AI}
\label{\detokenize{ch/ai:introduzione-ai-metodi-in-ai}}\label{\detokenize{ch/ai:book-ai-hs}}\label{\detokenize{ch/ai::doc}}
\sphinxAtStartPar
In questa sezione si descriveranno alcuni metodi utilizzati nelle applicazioni di \sphinxstylestrong{machine learning}. I contenuti sono organizzati in 3 sezioni, seguendo una delle più comuni classificazioni in machine learning.

\sphinxAtStartPar
\sphinxstylestrong{Approccio.} Alla completezza e al rigore dello sviluppo teorico dei metodi, viene preferita una descrizione dei metodi tramite esempi e applicazioni.

\sphinxAtStartPar
Benché questo possa essere un approccio ad alto rischio di creazione di utenti acritici di strumenti che non comprendono, la speranza è di mitigare questo rischio con continui moniti a prestare attenzione e un supporto del lettore da parte di gente con un minimo di esperienza.

\sphinxAtStartPar
\sphinxstylestrong{Argomenti.} In questa sezione verranno presentati alcuni metodi e applicazioni del \sphinxstylestrong{machine learning}, che possono essere classificate in tre grandi classi di apprendimento:
\begin{itemize}
\item {} 
\sphinxAtStartPar
SL, supervised learning: regression and classification

\item {} 
\sphinxAtStartPar
UL, unsupervised learning: clustering

\item {} 
\sphinxAtStartPar
ML, machine learning: control

\end{itemize}

\sphinxAtStartPar
Dopo aver presentato le tecniche classiche, verranno introdotte le reti neurali, gli algoritmi fondamentali che hanno permesso un uso pratico ed efficiente di reti profonde, e alcune architetture fondamentali di reti neurali.

\sphinxAtStartPar
Le applicazioni verranno affrontate inizialmente con approcci classici, affidandoci alla libreria \sphinxhref{https://scikit-learn.org}{sci\sphinxhyphen{}kit}, e successivamente con tecniche «deep» grazie alla libreria \sphinxhref{https://pytorch.org}{PyTorch}.

\sphinxstepscope


\chapter{Supervised Learning}
\label{\detokenize{ch/ai/sl:supervised-learning}}\label{\detokenize{ch/ai/sl:ai-sl}}\label{\detokenize{ch/ai/sl::doc}}
\sphinxstepscope


\chapter{Unsupervised Learning}
\label{\detokenize{ch/ai/ul:unsupervised-learning}}\label{\detokenize{ch/ai/ul:ai-ul}}\label{\detokenize{ch/ai/ul::doc}}
\sphinxAtStartPar
Le principali attività dell’applrendimento non supervisionato sono:
\begin{itemize}
\item {} 
\sphinxAtStartPar
il clustering: raggruppamento dei dati in classi più o meno omogenee

\item {} 
\sphinxAtStartPar
la riduzione delle dimensioni: sintesi delle dinamiche/informazioni «principali» contenute nei dati. Una caratteristica che permette di distinguere gli algoritmi è la definizione di «principali»; così ad esempio:
\begin{itemize}
\item {} 
\sphinxAtStartPar
PCA (o la cara vecchia SVD): seleziona le dinamiche «più energetiche» tra di loro ortogonali contenute in un segnale

\item {} 
\sphinxAtStartPar
ICA: seleziona le dinamiche «maggiormente indipendenti» contenute nel segnale

\end{itemize}

\sphinxAtStartPar
Un confronto tra ICA e PCA può chiarire il significato delle diverse definizioni e le differenze nei risultati prodotti.

\end{itemize}

\sphinxstepscope


\section{PCA}
\label{\detokenize{ch/ai/pca:pca}}\label{\detokenize{ch/ai/pca:ia-ul-pca}}\label{\detokenize{ch/ai/pca::doc}}

\subsection{Esempio: compressione di immagini}
\label{\detokenize{ch/ai/pca:esempio-compressione-di-immagini}}
\sphinxAtStartPar
Un’immagine in scala di grigio può essere rappresentata con una matrice \(\mathbf{A}\), i cui elementi rappresentano il valore di grigio di ogni pixel.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0.5, 511.5, 511.5, \PYGZhy{}0.5)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{d15539d1970035394b1f718ad297932c613ca3b0921d5661e4564c59114a0002}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Preprocessing e SVD}
\label{\detokenize{ch/ai/pca:preprocessing-e-svd}}
\sphinxAtStartPar
Viene rimosso il valore medio dall’immagine, prima di valutare la SVD della matrice \(\mathbf{A}\)

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Risultati della SVD}
\label{\detokenize{ch/ai/pca:risultati-della-svd}}
\sphinxAtStartPar
I valori singolari rappresentano il contenuto energetico dei singoli modi. La somma cumulativa dei valori singolari rappresenta il contenuto energetico della

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{c6965c58085cc4d71bfdf313c435b306c7f61cb53c920e592c9eb51a68c74a30}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Ricostruzione dell’immagine compressa}
\label{\detokenize{ch/ai/pca:ricostruzione-dell-immagine-compressa}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Image reconstruction with 100 singular values:
\PYGZgt{} Energy error [\PYGZpc{} original]: 0.1647581016503445
\PYGZgt{} Storage      [\PYGZpc{} original]: 0.3870964050292969
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{f13f70c80b4dea160b1518e19e0e9bcfcbbb4dd7aaf247870e153c2052f08e9f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope


\section{ICA e PCA}
\label{\detokenize{ch/ai/ica-pca:ica-e-pca}}\label{\detokenize{ch/ai/ica-pca:ai-ul-ica-pca}}\label{\detokenize{ch/ai/ica-pca::doc}}

\subsection{Riferimenti}
\label{\detokenize{ch/ai/ica-pca:riferimenti}}
\sphinxAtStartPar
\sphinxstylestrong{scikit}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://scikit-learn.org/dev/modules/generated/sklearn.decomposition.FastICA.html}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Carten Klein}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/akcarsten/}

\item {} 
\sphinxAtStartPar
\sphinxurl{https://github.com/akcarsten/Independent\_Component\_Analysis}

\end{itemize}

\sphinxstepscope


\subsection{FastICA on 2D point clouds}
\label{\detokenize{ch/ai/ica-pca-example-2d:fastica-on-2d-point-clouds}}\label{\detokenize{ch/ai/ica-pca-example-2d:ai-ul-ica-pca-example-2d}}\label{\detokenize{ch/ai/ica-pca-example-2d::doc}}
\sphinxAtStartPar
Esempio disponibile sul sito di \sphinxhref{https://scikit-learn.org/dev/auto\_examples/decomposition/plot\_ica\_vs\_pca.html\#sphx-glr-auto-examples-decomposition-plot-ica-vs-pca-py}{scikit\sphinxhyphen{}learn}.


\subsubsection{Librerie e funzioni di comodo}
\label{\detokenize{ch/ai/ica-pca-example-2d:librerie-e-funzioni-di-comodo}}

\paragraph{Import librerie}
\label{\detokenize{ch/ai/ica-pca-example-2d:import-librerie}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{reset} \PYGZhy{}f

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{sklearn}\PYG{n+nn}{.}\PYG{n+nn}{decomposition} \PYG{k+kn}{import} \PYG{n}{PCA}\PYG{p}{,} \PYG{n}{FastICA}

\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\paragraph{Funzioni utili}
\label{\detokenize{ch/ai/ica-pca-example-2d:funzioni-utili}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} utils}

\PYG{k}{def} \PYG{n+nf}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{n}{axis\PYGZus{}list}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} util function for plotting scatter plots \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}
        \PYG{n}{S}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{S}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{o}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{steelblue}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}
    \PYG{p}{)}
    \PYG{k}{if} \PYG{n}{axis\PYGZus{}list} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{axis}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{n}{label} \PYG{o+ow}{in} \PYG{n}{axis\PYGZus{}list}\PYG{p}{:}
            \PYG{n}{x\PYGZus{}axis}\PYG{p}{,} \PYG{n}{y\PYGZus{}axis} \PYG{o}{=} \PYG{n}{axis} \PYG{o}{/} \PYG{n}{axis}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}
            \PYG{n}{plt}\PYG{o}{.}\PYG{n}{quiver}\PYG{p}{(}
                \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{x\PYGZus{}axis}\PYG{p}{,}
                \PYG{n}{y\PYGZus{}axis}\PYG{p}{,}
                \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{11}\PYG{p}{,}
                \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{,}
                \PYG{n}{scale}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{,}
                \PYG{n}{color}\PYG{o}{=}\PYG{n}{color}\PYG{p}{,}
                \PYG{n}{label}\PYG{o}{=}\PYG{n}{label}\PYG{p}{,}
            \PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{vlines}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{black}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylim}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{set\PYGZus{}aspect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{equal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Generazione campione}
\label{\detokenize{ch/ai/ica-pca-example-2d:generazione-campione}}
\sphinxAtStartPar
La formulazione più comune dei metodi usa l’espressione
\begin{equation*}
\begin{split}\mathbf{X} = \mathbf{A} \, \mathbf{S} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
che lega osservazioni \(X\) e segnali \(S\) tramite la matrice di mixing \(A\). Per le strutture dati di Python, è conveniente (\sphinxstylestrong{todo} \sphinxstyleemphasis{provare! O è dovuto solo alla forma mentis di chi usa Python?}) scrivere la relazione trasposta,
\begin{equation*}
\begin{split}\mathbf{X}^T = \mathbf{S}^T \, \mathbf{A}^T \ .\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Sample data generation}
\PYG{c+c1}{\PYGZsh{} Initialize a default random number generator}
\PYG{n}{rng} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{default\PYGZus{}rng}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} rng = np.random.RandomState(42)   }
\PYG{c+c1}{\PYGZsh{} np.random.RandomState() is deprecated! Use random.default\PYGZus{}rng(),}
\PYG{c+c1}{\PYGZsh{} but FastICA needs a np.random.RandomSstate as an optional input random\PYGZus{}state}

\PYG{c+c1}{\PYGZsh{} Create data: non\PYGZhy{}isotropic mixing of 2 t\PYGZhy{}Student variables:}
\PYG{c+c1}{\PYGZsh{} 1. Create signals S, as 2 t\PYGZhy{}Student distributions}
\PYG{c+c1}{\PYGZsh{} 1. sampling from a t\PYGZhy{}Student distribution with degrees of freedom df}
\PYG{c+c1}{\PYGZsh{} matrix S has dimensions (n\PYGZus{}rows, n\PYGZus{}cols) = (n\PYGZus{}samples, n\PYGZus{}dim), interpreting}
\PYG{c+c1}{\PYGZsh{} each row as a sample, and each row as a dimension of the data}
\PYG{n}{df}\PYG{p}{,} \PYG{n}{n\PYGZus{}samples}\PYG{p}{,} \PYG{n}{n\PYGZus{}dims} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{l+m+mi}{2}
\PYG{n}{S} \PYG{o}{=} \PYG{n}{rng}\PYG{o}{.}\PYG{n}{standard\PYGZus{}t}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{n}{n\PYGZus{}samples}\PYG{p}{,} \PYG{n}{n\PYGZus{}dims}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 2. scale one component}
\PYG{n}{S}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{2.0}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{S} \PYG{o}{/} \PYG{n}{S}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True independent signals, S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} 3. Mix components}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Mixing matrix}
\PYG{n}{X} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{n}{A}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}              \PYG{c+c1}{\PYGZsh{} Generate observations}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{X} \PYG{o}{/} \PYG{n}{X}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Observations, X = A S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Text(0.5, 1.0, \PYGZsq{}Observations, X = A S\PYGZsq{})
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{8ff1ab26894ba132df999198647f33b134f8fde00b0a45134affaba03dd74337}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{ICA e PCA}
\label{\detokenize{ch/ai/ica-pca-example-2d:ica-e-pca}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} PCA}
\PYG{n}{pca} \PYG{o}{=} \PYG{n}{PCA}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{S\PYGZus{}pca\PYGZus{}} \PYG{o}{=} \PYG{n}{pca}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} ICA}
\PYG{n}{ica} \PYG{o}{=} \PYG{n}{FastICA}\PYG{p}{(}\PYG{n}{random\PYGZus{}state}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{whiten}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arbitrary\PYGZhy{}variance}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} ica = FastICA(random\PYGZus{}state=np.random.RandomState(42), whiten=\PYGZdq{}arbitrary\PYGZhy{}variance\PYGZdq{})}
\PYG{n}{S\PYGZus{}ica\PYGZus{}} \PYG{o}{=} \PYG{n}{ica}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Estimate the sources}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Risultati}
\label{\detokenize{ch/ai/ica-pca-example-2d:risultati}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Print results:}
\PYG{c+c1}{\PYGZsh{} Normalization: principal and independent components are usually defined up to a multiplicative factor;}
\PYG{c+c1}{\PYGZsh{} PCA and ICA provides information abouth the \PYGZdq{}shape\PYGZdq{} of the main components in a signal; usually, it\PYGZsq{}s a}
\PYG{c+c1}{\PYGZsh{} good practice to have normalized info/results, that contains only shape info and no other arbitrary (non)\PYGZhy{}info}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} PCA results are usually normalized}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} ICA results seem to be not normalized by the algorithm; easy to perform normalization, as done below,}
\PYG{c+c1}{\PYGZsh{}   to have unit\PYGZhy{}norm vectors to be easily compared with PCA.}
\PYG{c+c1}{\PYGZsh{}   If normalization done outside functions, remember to normalize both signals and mixing matrix}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{PCA, principal components (rows of the matrix)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pca}\PYG{o}{.}\PYG{n}{components\PYGZus{}} \PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ICA. indepdent components (rows of the matrix)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ica}\PYG{o}{.}\PYG{n}{mixing\PYGZus{}}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}                                                        \PYG{c+c1}{\PYGZsh{} non normalized}
\PYG{c+c1}{\PYGZsh{} print(ica.mixing\PYGZus{}.T / np.linalg.norm(ica.mixing\PYGZus{}.T,axis=1)[:, np.newaxis])  \PYGZsh{} normalized}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
PCA, principal components (rows of the matrix)
[[\PYGZhy{}0.48647086 \PYGZhy{}0.8736968 ]
 [ 0.8736968  \PYGZhy{}0.48647086]]

ICA. indepdent components (rows of the matrix)
[[\PYGZhy{}9.46908181e+02 \PYGZhy{}1.89462935e+03]
 [ 6.85936578e+02 \PYGZhy{}8.07940837e\PYGZhy{}01]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Plots}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{S} \PYG{o}{/} \PYG{n}{S}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{True independent signals, S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{axis\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{pca}\PYG{o}{.}\PYG{n}{components\PYGZus{}}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{orange}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PCA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ica}\PYG{o}{.}\PYG{n}{mixing\PYGZus{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{red}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ICA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{X} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis\PYGZus{}list}\PYG{o}{=}\PYG{n}{axis\PYGZus{}list}\PYG{p}{)}
\PYG{n}{legend} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{upper left}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{legend}\PYG{o}{.}\PYG{n}{set\PYGZus{}zorder}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Observations, X = A S}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{S\PYGZus{}pca\PYGZus{}} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{S\PYGZus{}pca\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PCA recovered signal, \PYGZdl{}S\PYGZus{}}\PYG{l+s+si}{\PYGZob{}PCA\PYGZcb{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{plot\PYGZus{}samples}\PYG{p}{(}\PYG{n}{S\PYGZus{}ica\PYGZus{}} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{S\PYGZus{}ica\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ICA recovered signal, \PYGZdl{}S\PYGZus{}}\PYG{l+s+si}{\PYGZob{}ICA\PYGZcb{}}\PYG{l+s+s2}{\PYGZdl{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots\PYGZus{}adjust}\PYG{p}{(}\PYG{l+m+mf}{0.09}\PYG{p}{,} \PYG{l+m+mf}{0.04}\PYG{p}{,} \PYG{l+m+mf}{0.94}\PYG{p}{,} \PYG{l+m+mf}{0.94}\PYG{p}{,} \PYG{l+m+mf}{0.26}\PYG{p}{,} \PYG{l+m+mf}{0.36}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{202fb4a67cbbf402e481e6a7fc837c087fc139b5c7079d8a0091d101d910c739}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\subsection{ICA e PCA: segnali in tempo}
\label{\detokenize{ch/ai/ica-pca-example-time:ica-e-pca-segnali-in-tempo}}\label{\detokenize{ch/ai/ica-pca-example-time:ai-ul-ica-pca-example-time}}\label{\detokenize{ch/ai/ica-pca-example-time::doc}}
\sphinxstepscope


\subsection{ICA e PCA \sphinxhyphen{} dettagli}
\label{\detokenize{ch/ai/ica-pca-details:ica-e-pca-dettagli}}\label{\detokenize{ch/ai/ica-pca-details::doc}}
\sphinxAtStartPar
Prendendo spunto da quanto fatto da \sphinxhref{https://github.com/akcarsten/Independent\_Component\_Analysis}{A.K.Carsten} si discutono alcuni dettagli dell’algoritmo ICA,%
\begin{footnote}[1]\sphinxAtStartFootnote
A.Hyvarinen, E.Oja *Independent component analysis: algorithms and applications»
%
\end{footnote} applicandolo a un problema di riconoscimento delle componenti indipendenti di segnali in tempo.

\sphinxAtStartPar
In particolare, si vuole discutere \sphinxstylestrong{todo}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
i dettagli dell’algoritmo, prestando attenzione a
\begin{itemize}
\item {} 
\sphinxAtStartPar
la relazione «non\sphinxhyphen{}gaussianità» \(\sim\) «indipendenza»

\item {} 
\sphinxAtStartPar
la misura di non gaussianità tramite neg\sphinxhyphen{}entropia, e le sue approssimazioni

\item {} 
\sphinxAtStartPar
l’espressione dell’iterazione di Newton nell’ottimizzazione della neg\sphinxhyphen{}entropia, che dà vita a un problema di punto fisso

\end{itemize}

\item {} 
\sphinxAtStartPar
la necessità della non\sphinxhyphen{}gaussianità dei segnali

\end{itemize}


\subsubsection{Librerie e funzioni utili}
\label{\detokenize{ch/ai/ica-pca-details:librerie-e-funzioni-utili}}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Generazione segnale}
\label{\detokenize{ch/ai/ica-pca-details:generazione-segnale}}
\sphinxAtStartPar
Viene generato un campione test con 200 campioni di 3 osservazioni, come risultato del mix di 3 segnali indipendenti, da ricostruire con l’algoritmo ICA.

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{af2e0e0f0efb820ae2ee778cbb7b4e6da412b0d214bf3833439de303e76f5e01}.png}

\noindent\sphinxincludegraphics{{734e43a58d86fe173d5e90854135661292f903de9be1925326eefcdd145504a5}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Algoritmo}
\label{\detokenize{ch/ai/ica-pca-details:algoritmo}}

\paragraph{Pre\sphinxhyphen{}processing}
\label{\detokenize{ch/ai/ica-pca-details:pre-processing}}
\sphinxAtStartPar
L’osservazione \(\mathbf{X}\) vengono \sphinxstylestrong{depurate dalla media} e viene usata una trasformazione per combinare le osservazioni originali e ottenere un nuovo segnale \(\mathbf{X}_w\) con \sphinxstylestrong{componenti non correlate}. Il procedimento viene illustrato per i dati organizzati nella matrice,
\begin{equation*}
\begin{split}\mathbf{X} = \begin{bmatrix} \mathbf{x}_1 | \mathbf{x}_2 | \dots | \mathbf{x}_{s} \end{bmatrix} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
in cui la colonna \(j\)\sphinxhyphen{}esima contiene le \(n_x\) osservazioni relative all’indice \(j\) (istante di tempo, paziente,…), mentre la riga \(i\)\sphinxhyphen{}esima contiene l’osservazione della quantità identificata dall’indice \(i\) per ogni valore di \(j\) (istante di tempo, paziente,…).
\subsubsection*{Teoria}

\sphinxAtStartPar
Vengono svolte due operazioni:
\begin{itemize}
\item {} 
\sphinxAtStartPar
rimozione della media dalle osservazioni di ogni quantità, quindi rimozione del valore medio di ogni riga,
\$\(X_{ij} \quad \leftarrow \quad X_{ij} - \frac{1}{n_s} \sum_{j = 1}^{n_s} X_{ij} \ ,\)\$
in modo da avere i nuovi segnali a media nulla;

\item {} 
\sphinxAtStartPar
ricerca di una trasformazione di coordinate (combinazione delle osservazioni) che renda la nuove componenti non correlate. Una stima senza bias della correlazione è
\begin{equation*}
\begin{split}\hat{\mathbf{R}} = \frac{1}{n_s - 1} \mathbf{X} \, \mathbf{X}^* \ .\end{split}
\end{equation*}
\sphinxAtStartPar
In generale, questa è una matrice piena di dimensioni \((n_x, n_x)\). Si vuole cercare la trasformazione di coordinate \(\mathbf{X}_w = \mathbf{W}_w \mathbf{X}\), che garantisce che la nuove osservazioni siano non correlate con varianza unitaria (come \sphinxstyleemphasis{white noise}, e da qui il nome \sphinxstyleemphasis{whitening}), cioè
\begin{equation*}
\begin{split}\mathbf{I} = \hat{\mathbf{R}}_w = \frac{1}{n_s - 1} \mathbf{X}_w \, \mathbf{X}_w^* = \frac{1}{n_s - 1} \mathbf{W}_w \, \mathbf{X} \, \mathbf{X}^*  \, \mathbf{W}_w^* = \mathbf{W}_w \, \hat{\mathbf{R}} \, \mathbf{W}_w^*\end{split}
\end{equation*}
\sphinxAtStartPar
E” possibile trovare la matrice desiderata \(\mathbf{W}_w\) usando una tecnica di scomposizione della matrice di correlazione \(\hat{\mathbf{R}}\), simmetrica (semi)definita positiva, come ad esempio la
\begin{itemize}
\item {} 
\sphinxAtStartPar
scomposizione agli autovalori, \(\hat{\mathbf{R}} = \mathbf{E} \, \symbf{\Lambda} \, \mathbf{E}^{-1}\), con \(\symbf{\Lambda}\) diagonale; sfruttando le proprietà delle matrici sdp, si può scrivere  \(\hat{\mathbf{R}} = \mathbf{E} \, \symbf{\Lambda} \, \mathbf{E}^*\), con la matrice \(\mathbf{E}\) ortogonale tale che \(\mathbf{E} \, \mathbf{E}^* = \mathbf{I}\).

\item {} 
\sphinxAtStartPar
la SVD, \(\hat{\mathbf{R}} = \mathbf{U} \symbf{\Sigma} \mathbf{V}^*\), con \(\symbf{\Sigma}\) diagonale; nel caso di matrice di partenza sdp, si può scrivere si può scrivere \(\hat{\mathbf{R}} = \mathbf{U} \symbf{\Sigma} \mathbf{U}^*\), con la matrice \(\mathbf{E}\) ortogonale tale che \(\mathbf{U} \, \mathbf{U}^* = \mathbf{I}\).

\end{itemize}

\sphinxAtStartPar
Sfruttando quindi la proprietà delle scomposizioni presentate sopra, osservando l’analogia del risultato delle due scomposizioni nel caso di matrice sdp, e definendo \(\symbf{\Sigma}^{1/2}\) la matrice diagonale con elementi le radici quadrate di \(\symbf{\Sigma}\), si può scrivere
\begin{equation*}
\begin{split}\begin{aligned}
     \mathbf{I}
     & = \mathbf{W}_w \, \hat{\mathbf{R}} \, \mathbf{W}_w^* = \\
     & = \mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* \, \mathbf{W}_w^* = \\
     & = \mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* \, \mathbf{W}_w^* = \\
     & = (\mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* ) \, (\mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* )^* \ ,
  \end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
e quindi (\sphinxstylestrong{todo} \sphinxstyleemphasis{gisutificare la comparsa di \(\mathbf{U}^* \mathbf{U}\) per ottenere una matrice quadrata, giustificare la scelta di \(\mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* = \mathbf{I}\)})
\begin{equation*}
\begin{split}\mathbf{W}_w \, \mathbf{U} \symbf{\Sigma}^{\frac{1}{2}} \mathbf{U}^* = \mathbf{I}
  \qquad \rightarrow \qquad 
  \mathbf{W}_w =  \mathbf{U}^* \symbf{\Sigma}^{-\frac{1}{2}} \mathbf{U}
  \end{split}
\end{equation*}
\end{itemize}

\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}
\end{sphinxuseclass}
\end{sphinxuseclass}

\paragraph{FastICA}
\label{\detokenize{ch/ai/ica-pca-details:fastica}}
\sphinxAtStartPar
Viene qui illustrato l’algoritmo FastICA\sphinxfootnotemark[1]

\sphinxAtStartPar
\sphinxstylestrong{todo}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fastIca}\PYG{p}{(}\PYG{n}{signals}\PYG{p}{,}  \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{thresh}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{,} \PYG{n}{iterations}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{m}\PYG{p}{,} \PYG{n}{n} \PYG{o}{=} \PYG{n}{signals}\PYG{o}{.}\PYG{n}{shape}

    \PYG{c+c1}{\PYGZsh{} Initialize random weights}
    \PYG{n}{W} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{c} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{w} \PYG{o}{=} \PYG{n}{W}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n}{w} \PYG{o}{=} \PYG{n}{w} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{w} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

            \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}
            \PYG{n}{lim} \PYG{o}{=} \PYG{l+m+mi}{100}
            \PYG{k}{while} \PYG{p}{(}\PYG{p}{(}\PYG{n}{lim} \PYG{o}{\PYGZgt{}} \PYG{n}{thresh}\PYG{p}{)} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{iterations}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}

                \PYG{c+c1}{\PYGZsh{} Dot product of weight and signal}
                \PYG{n}{ws} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{w}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,} \PYG{n}{signals}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Pass w*s into contrast function g}
                \PYG{n}{wg} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tanh}\PYG{p}{(}\PYG{n}{ws} \PYG{o}{*} \PYG{n}{alpha}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

                \PYG{c+c1}{\PYGZsh{} Pass w*s into g prime}
                \PYG{n}{wg\PYGZus{}} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{square}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{tanh}\PYG{p}{(}\PYG{n}{ws}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{n}{alpha}

                \PYG{c+c1}{\PYGZsh{} Update weights}
                \PYG{n}{wNew} \PYG{o}{=} \PYG{p}{(}\PYG{n}{signals} \PYG{o}{*} \PYG{n}{wg}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{wg\PYGZus{}}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{w}\PYG{o}{.}\PYG{n}{squeeze}\PYG{p}{(}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Decorrelate weights              }
                \PYG{n}{wNew} \PYG{o}{=} \PYG{n}{wNew} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{wNew}\PYG{p}{,} \PYG{n}{W}\PYG{p}{[}\PYG{p}{:}\PYG{n}{c}\PYG{p}{]}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}\PYG{p}{,} \PYG{n}{W}\PYG{p}{[}\PYG{p}{:}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{wNew} \PYG{o}{=} \PYG{n}{wNew} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{wNew} \PYG{o}{*}\PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Calculate limit condition}
                \PYG{n}{lim} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{wNew} \PYG{o}{*} \PYG{n}{w}\PYG{p}{)}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}

                \PYG{c+c1}{\PYGZsh{} Update weights}
                \PYG{n}{w} \PYG{o}{=} \PYG{n}{wNew}

                \PYG{c+c1}{\PYGZsh{} Update counter}
                \PYG{n}{i} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

            \PYG{n}{W}\PYG{p}{[}\PYG{n}{c}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{n}{w}\PYG{o}{.}\PYG{n}{T}
    \PYG{k}{return} \PYG{n}{W}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Applicazione del metodo al segnale}
\label{\detokenize{ch/ai/ica-pca-details:applicazione-del-metodo-al-segnale}}
\sphinxAtStartPar
Il metodo viene applicato al problema considerato. In questo caso (segnali non gaussiani,…) il metodo riesce a ricostruire bene (\sphinxstylestrong{todo} \sphinxstyleemphasis{è un bene «a occhio», qualitativo. Quantificare!}) i 3 segnali indipendenti di partenza \sphinxstylestrong{a meno di un fattore moltiplicativo}, arbitrarietà propria del metodo.

\sphinxAtStartPar
\sphinxstylestrong{todo} Dire qualcosa sulle componenti principali indipendenti, discutendo le componenti della matrice \(\mathbf{W}\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Preprocessing}
\PYG{c+c1}{\PYGZsh{} Center signals}
\PYG{n}{Xc}\PYG{p}{,} \PYG{n}{meanX} \PYG{o}{=} \PYG{n}{center}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Whiten mixed signals}
\PYG{n}{Xw}\PYG{p}{,} \PYG{n}{whiteM} \PYG{o}{=} \PYG{n}{whiten}\PYG{p}{(}\PYG{n}{Xc}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} FastICA}
\PYG{n}{W} \PYG{o}{=} \PYG{n}{fastIca}\PYG{p}{(}\PYG{n}{Xw}\PYG{p}{,}  \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Find unmixed signals using}
\PYG{n}{unMixed} \PYG{o}{=} \PYG{n}{Xw}\PYG{o}{.}\PYG{n}{T}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{W}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}


\begin{sphinxuseclass}{cell}
\begin{sphinxuseclass}{tag_hide-input}\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{5229b2d554bea96db9ecd8a27fc049d23b561deda63f503c82c45602f29eddfb}.png}

\noindent\sphinxincludegraphics{{8c2e9c6f848caa9d0a1675129104394513a340c5eea74939fde5d631b3084b6a}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Comparison of matrices involved, A, whiteM, W}
\PYG{c+c1}{\PYGZsh{} todo...}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Reinforcement Learning}
\label{\detokenize{ch/ai/ml:reinforcement-learning}}\label{\detokenize{ch/ai/ml:ai-rl}}\label{\detokenize{ch/ai/ml::doc}}
\sphinxstepscope


\part{Supporto tecnico}

\sphinxstepscope


\chapter{Supporto tecnico}
\label{\detokenize{ch/support:supporto-tecnico}}\label{\detokenize{ch/support:programming-hs-support-hs}}\label{\detokenize{ch/support::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
git

\item {} 
\sphinxAtStartPar
Servizi Google

\item {} 
\sphinxAtStartPar
TeX

\end{itemize}







\renewcommand{\indexname}{Indice}
\printindex
\end{document}