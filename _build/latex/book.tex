%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduzione alla programmazione}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Introduzione alla programmazione per le scuole superiori}
\date{Nov 07, 2024}
\release{}
\author{basics}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{intro::doc}}


\sphinxAtStartPar
Questo libro fa parte del materiale pensato per \sphinxhref{https://basics2022.github.io/bbooks-hs}{le scuole superiori}

\sphinxAtStartPar
\sphinxstylestrong{Obiettivi generali.} Questo lavoro punta ad essere un’opera di \sphinxstyleemphasis{formazione alla} \sphinxstylestrong{tirchieria}, \sphinxstylestrong{prigrizia} \sphinxstyleemphasis{e} \sphinxstylestrong{onestà}, almeno in ambito informatico. I più benvolenti potranno riassumere questo obiettivo come il desiderio di \sphinxstyleemphasis{non buttare nel WC soldi, tempo, e pazienza}.

\sphinxAtStartPar
Oltre alle nozioni minime, l’obiettivo principale di questo libro è la formazione a:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{indipendenza} in ambito informatico: evitare di pagare per qualcosa che non serve; evitare di pagare per qualcosa di inutile o dannoso in presenza di alternative libere; meglio dedicare le risorse a ciò che vale la pena pagare

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ordine}: i moderni strumenti informatici permettono di lavorare in maniera ordinata, risparmiando tempo, soldi e pazienza

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{trasparenza} e \sphinxstylestrong{onestà}: anche se spesso in maniera non lineare, la conoscenza procede seguendo il metodo scientifico: i risultati mostrati e le tesi proposte devono essere supportate da dati e logica; i dati e le analisi svolte per poter produrre risultati devono essere disponibili, controllabili e soggetti a critica. Tutto il resto, almeno qui, almeno nell’ambito della conoscenza che procede con il metodo scientifico, sarà considerata confusione nella migliore delle ipotesi o direttamente \sphinxstyleemphasis{merda}.

\end{itemize}

\sphinxAtStartPar
Questo stesso libro è scritto seguendo questi criteri: oltre al dispositivo elettronico usato per consultare il materiale (online o offline, una volta scaricato), non è necessaria la spesa per nessun altro dispositivo o infrastruttura informatica; i sorgenti del materiale è sviluppato localmente, ospitato e disponibile su \sphinxhref{https://github.com}{Github} all’indirizzo \sphinxurl{https://github.com/Basics2022/bbooks-programming-hs}.

\sphinxAtStartPar
\sphinxstylestrong{necessità di una connessione internet, se non si porta il progetto su un sistema locale, con tutti gli strumenti necessari \sphinxhyphen{} non tanti, e standard, ma comunque devono esserci “per funzionare”}



\sphinxAtStartPar
\sphinxstylestrong{Metodo.}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Impostazione degli strumenti necessari.} \sphinxstylestrong{todo}…

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Linguaggio di programmazione.} In questa introduzione si sceglie di usare \sphinxstylestrong{Python} come linguaggio di programmazione.
Un approccio più generale all’informatica e alla programmazione prevederebbe l’utilizzo di altri linguaggio di programmazione (come C).
Considerata la \sphinxstylestrong{diffusione} di Python, la quantità di \sphinxstylestrong{librerie disponibili} (con eventuali binding a librerie sviluppate usando linguaggi di programmazione più efficienti) e strumenti per la \sphinxstylestrong{programmazione collaborativa} e remota (\sphinxstylestrong{Colab}, \sphinxstylestrong{Jupyter},…), Python risulta comunque una buona scelta per un corso improntato alla presentazione delle basi di programmazione dirette a un’applicazione abbastanza immediata.

\sphinxAtStartPar
Verranno posta attenzione sulla sintassi “particolare” di Python quando si discosta maggiormente dagli altri linguaggi di programmazione.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Argomenti.} \sphinxstylestrong{todo}…

\end{itemize}

\sphinxstepscope


\part{Introduzione alla programmazione}

\sphinxstepscope


\chapter{Introduzione alla programmazione \sphinxhyphen{} in Python}
\label{\detokenize{ch/programming:introduzione-alla-programmazione-in-python}}\label{\detokenize{ch/programming:book-programming-intro-hs}}\label{\detokenize{ch/programming::doc}}
\sphinxAtStartPar
L’introduzione alla programmazione in Python userà le risorse messe a disposizione da \sphinxhref{https://www.google.com}{Google} con il progetto \sphinxhref{https://jupyter.org}{Jupyter} per lo sviluppo di codice open\sphinxhyphen{}source, con open\sphinxhyphen{}standard e servizi interattivi utilizzabili su diversi dispositivi usando diversi linguaggi di programmazione, come \sphinxhref{https://python.org}{Python}, \sphinxhref{https://julialang.org}{Julia} o \sphinxhref{https://www.r-project.org}{R}

\sphinxAtStartPar
Oltre al dispositivo elettronico utilizzato per consultare al materiale, non è necessario nessun altro dispositivo informatico: un account Google personale permette l’accesso libero ai servizi base di cloud computing di \sphinxhref{https://colab.research.google.com}{Colab}

\sphinxstepscope


\chapter{Variabili, tipi e funzioni elementari built\sphinxhyphen{}in}
\label{\detokenize{ch/programming/types:variabili-tipi-e-funzioni-elementari-built-in}}\label{\detokenize{ch/programming/types::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
tipi

\item {} 
\sphinxAtStartPar
variabili
\begin{itemize}
\item {} 
\sphinxAtStartPar
…

\item {} 
\sphinxAtStartPar
by\sphinxhyphen{}reference o by\sphinxhyphen{}value

\end{itemize}

\end{itemize}


\section{Commenti}
\label{\detokenize{ch/programming/types:commenti}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} I commenti permettono di aggiungere brevi descrizione al codice}

\PYG{c+c1}{\PYGZsh{} In Python, è possibile aggiungerre commenti al codice con il carattere \PYGZsh{}: tutto quello}
\PYG{c+c1}{\PYGZsh{} che viene dopo il carattere \PYGZsh{} su una riga è considerato un commento, e non codice da}
\PYG{c+c1}{\PYGZsh{} eseguire}

\PYG{c+c1}{\PYGZsh{} E\PYGZsq{} buona regola aggiungere qualche commento al codice, e sarebbe bene iniziare a farlo}
\PYG{c+c1}{\PYGZsh{} in lingua inglese:}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} il codice non è auto\PYGZhy{}esplicativo!}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{} il codice potrebbe essere usato da altri in giro per il mondo, ed è più probabile che}
\PYG{c+c1}{\PYGZsh{}   si conosca l\PYGZsq{}inglese invece dell\PYGZsq{}italiano}

\PYG{c+c1}{\PYGZsh{} So let\PYGZsq{}s switch to English for scripts, both for comments and \PYGZdq{}for variable names\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Comments are not documentation! **todo** Add some paragraph about documentation!}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Tipi built\sphinxhyphen{}in}
\label{\detokenize{ch/programming/types:tipi-built-in}}\begin{itemize}
\item {} 
\sphinxAtStartPar
numero: intero, reale, complesso

\item {} 
\sphinxAtStartPar
booleano

\item {} 
\sphinxAtStartPar
stringa

\item {} 
\sphinxAtStartPar
bytes

\item {} 
\sphinxAtStartPar
lista

\item {} 
\sphinxAtStartPar
tupla

\item {} 
\sphinxAtStartPar
insieme

\item {} 
\sphinxAtStartPar
dizionario, \(\texttt{dict}\)

\end{itemize}


\subsection{Numeri}
\label{\detokenize{ch/programming/types:numeri}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Numbers}

\PYG{l+s+sd}{in Python, variables are not delcared. Thus, a number variable is not defined}
\PYG{l+s+sd}{as an integer, a real or a complex variable, but it\PYGZsq{}s type is inferred by its}
\PYG{l+s+sd}{initialization}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Numbers}
\PYG{n}{a\PYGZus{}int} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{a\PYGZus{}real} \PYG{o}{=} \PYG{l+m+mf}{1.}
\PYG{n}{a\PYGZus{}complex} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{+} \PYG{l+m+mf}{0.}\PYG{n}{j}

\PYG{c+c1}{\PYGZsh{} Strings}
\PYG{n}{a\PYGZus{}str} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1.0}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}int)    : }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}int}\PYG{+w}{    }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}real)   : }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}real}\PYG{+w}{   }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}complex): }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}complex}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type(a\PYGZus{}str    ): }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}str}\PYG{+w}{    }\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
type(a\PYGZus{}int)    : \PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}real)   : \PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}complex): \PYGZlt{}class \PYGZsq{}complex\PYGZsq{}\PYGZgt{}
type(a\PYGZus{}str    ): \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Booleani \sphinxhyphen{} logici}
\label{\detokenize{ch/programming/types:booleani-logici}}

\subsection{Stringhe}
\label{\detokenize{ch/programming/types:stringhe}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Strings}

\PYG{l+s+sd}{strings are character }
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsq{}\PYGZbs{}nStrings\PYGZbs{}n\PYGZbs{}nstrings are character \PYGZbs{}n\PYGZsq{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Liste, tuple e insiemi}
\label{\detokenize{ch/programming/types:liste-tuple-e-insiemi}}

\subsection{Dizionari}
\label{\detokenize{ch/programming/types:dizionari}}
\sphinxstepscope


\chapter{Controllo del flusso}
\label{\detokenize{ch/programming/flow_control:controllo-del-flusso}}\label{\detokenize{ch/programming/flow_control::doc}}
\sphinxAtStartPar
Nei paradigmi di \sphinxstyleemphasis{programmazione imperativa} (\sphinxstylestrong{todo} fare riferimento ai paradigmi di programmazione. Ha senso questa distinzione?), vengono usate delle strutture di controllo del flusso di esecuzione di un programma.

\sphinxAtStartPar
Si possono distinguere due categorie delle strutture di controllo:
\begin{itemize}
\item {} 
\sphinxAtStartPar
condizionale ed alternativa: if, if\sphinxhyphen{}then, if\sphinxhyphen{}then\sphinxhyphen{}else

\item {} 
\sphinxAtStartPar
iterazione: for, while, …

\end{itemize}


\section{Alternativa}
\label{\detokenize{ch/programming/flow_control:alternativa}}

\subsection{\protect\(\texttt{if}\protect\)\sphinxhyphen{}\protect\(\texttt{then}\protect\) statement}
\label{\detokenize{ch/programming/flow_control:texttt-if-texttt-then-statement}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} if\PYGZhy{}then example \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} Try this script changing the user input}

\PYG{c+c1}{\PYGZsh{} User input}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{2}        \PYG{c+c1}{\PYGZsh{} a is initialize as an integer}
\PYG{c+c1}{\PYGZsh{} a = 2.1      \PYGZsh{} if a is initialized as a real, a \PYGZpc{} 2 perform automatic casting, int(a) \PYGZpc{} 2}
               \PYG{c+c1}{\PYGZsh{} uncomment previous line and try!}

\PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{odd}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} automatic casting into an int \PYGZhy{}\PYGZgt{} a \PYGZpc{} 2 = floor(a) \PYGZpc{} 2}
    \PYG{n}{word} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{even}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) is an }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{word}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ number}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (2) is an even number
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{\protect\(\texttt{if}\protect\)\sphinxhyphen{}\protect\(\texttt{then}\protect\)\sphinxhyphen{}\protect\(\texttt{else}\protect\) statement}
\label{\detokenize{ch/programming/flow_control:texttt-if-texttt-then-texttt-else-statement}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} if\PYGZhy{}then\PYGZhy{}else example\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} Try this script changing the user input}

\PYG{c+c1}{\PYGZsh{} User input}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{15}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{p}{)}\PYG{p}{:}     \PYG{c+c1}{\PYGZsh{} First condition}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{k}{elif} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o}{==} \PYG{l+m+mi}{2} \PYG{p}{)}\PYG{p}{:}   \PYG{c+c1}{\PYGZsh{} Other condition}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{k}{else}\PYG{p}{:}                  \PYG{c+c1}{\PYGZsh{} All the other conditions}
    \PYG{n}{reminder} \PYG{o}{=} \PYG{l+m+mi}{0}
    
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{User input (}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{). }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ \PYGZpc{} 3 = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{reminder}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
User input (15). 15 \PYGZpc{} 3 = 0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}



\section{Iterazione}
\label{\detokenize{ch/programming/flow_control:iterazione}}

\subsection{for loop}
\label{\detokenize{ch/programming/flow_control:for-loop}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} for loop examples}

\PYG{l+s+sd}{Loops over:}
\PYG{l+s+sd}{\PYGZhy{} elements of a list}
\PYG{l+s+sd}{\PYGZhy{} elements in range}
\PYG{l+s+sd}{\PYGZhy{} keys, values of a dict}
\PYG{l+s+sd}{\PYGZhy{} ...}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a list}
\PYG{n}{seq} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{4.} \PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{key}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{]}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the list: seq = }\PYG{l+s+si}{\PYGZob{}seq\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{el} \PYG{o+ow}{in} \PYG{n}{seq}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{element }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ has type }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{el}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a tuple}
\PYG{c+c1}{\PYGZsh{} ...}

\PYG{c+c1}{\PYGZsh{} Loop over elements of a range}
\PYG{n}{n\PYGZus{}el} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{range\PYGZus{}el} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the list, seq = }\PYG{l+s+si}{\PYGZob{}seq\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{range(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{) has type: }\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{range\PYGZus{}el}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{range(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{range\PYGZus{}el}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{range\PYGZus{}el}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Loop over keys, values of a dict}
\PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{k+kc}{True}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Loop over elements of the dict, d = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{d}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i}\PYG{p}{,}\PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{d}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Loop over elements of the list: seq = \PYGZob{}seq\PYGZcb{}
element a has type \PYGZlt{}class \PYGZsq{}str\PYGZsq{}\PYGZgt{}
element 3 has type \PYGZlt{}class \PYGZsq{}int\PYGZsq{}\PYGZgt{}
element 4.0 has type \PYGZlt{}class \PYGZsq{}float\PYGZsq{}\PYGZgt{}
element \PYGZob{}\PYGZsq{}key\PYGZsq{}: \PYGZsq{}value\PYGZsq{}\PYGZcb{} has type \PYGZlt{}class \PYGZsq{}dict\PYGZsq{}\PYGZgt{}

Loop over elements of the list, seq = \PYGZob{}seq\PYGZcb{}
range(5) has type: \PYGZlt{}class \PYGZsq{}range\PYGZsq{}\PYGZgt{}
range(5): range(0, 5)
0
1
2
3
4

Loop over elements of the dict, d = \PYGZob{}\PYGZsq{}a\PYGZsq{}: 1.0, \PYGZsq{}b\PYGZsq{}: 6, \PYGZsq{}c\PYGZsq{}: \PYGZob{}\PYGZsq{}c1\PYGZsq{}: 1, \PYGZsq{}c2\PYGZsq{}: True\PYGZcb{}\PYGZcb{}
a 1.0
b 6
c \PYGZob{}\PYGZsq{}c1\PYGZsq{}: 1, \PYGZsq{}c2\PYGZsq{}: True\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{while loop}
\label{\detokenize{ch/programming/flow_control:while-loop}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} while loop example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{k}{while} \PYG{p}{(} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5} \PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}\PYGZgt{} in while loop, a: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{after while loop, a: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{} in while loop, a: 4
\PYGZgt{}\PYGZgt{} in while loop, a: 5
after while loop, a: 5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{altri cicli}
\label{\detokenize{ch/programming/flow_control:altri-cicli}}
\sphinxAtStartPar
\sphinxstylestrong{todo}

\sphinxstepscope


\chapter{Funzioni}
\label{\detokenize{ch/programming/functions:funzioni}}\label{\detokenize{ch/programming/functions::doc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a function to tell if a number is positive or not}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function returning True if x\PYGZgt{}0, False if x\PYGZlt{}=0 \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} User input to test the function: tuple of numbers}
\PYG{n}{n\PYGZus{}tuple} \PYG{o}{=} \PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{.003}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.4} \PYG{p}{]}

\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Test function on all the elements in the user\PYGZhy{}defined tuple}
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n}{n\PYGZus{}tuple}\PYG{p}{:}
    \PYG{k}{if} \PYG{p}{(} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)} \PYG{p}{)}\PYG{p}{:} 
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{not }\PYG{l+s+s1}{\PYGZsq{}}
        
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{n}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ is }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{string}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{positive}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}1 is not positive
2.0 is positive
0.003 is positive
0.3333333333333333 is positive
\PYGZhy{}2.2 is not positive
0 is not positive
\PYGZhy{}7.4 is not positive
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Default value of function arguments}
\label{\detokenize{ch/programming/functions:default-value-of-function-arguments}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZgt{} Define a user function to tell is the first argument is greater than the second.}
\PYG{c+c1}{\PYGZsh{} If no second argument is given, it\PYGZsq{}s set = 0 (default value, defined in the function)}
\PYG{k}{def} \PYG{n+nf}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}  \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{return} \PYG{n}{is\PYGZus{}positive}\PYG{p}{(}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{p}{)}

\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{, }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Is }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ greater than  0 ? is\PYGZus{}greater\PYGZus{}than(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{a}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{,    ):}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{is\PYGZus{}greater\PYGZus{}than}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Is \PYGZhy{}2 greater than \PYGZhy{}3? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2, \PYGZhy{}3):True
Is \PYGZhy{}2 greater than  0 ? is\PYGZus{}greater\PYGZus{}than(\PYGZhy{}2,    ):False
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\chapter{Classi}
\label{\detokenize{ch/programming/oo:classi}}\label{\detokenize{ch/programming/oo::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
classi, metodi, oggetti

\item {} 
\sphinxAtStartPar
ereditarietà, overloading

\end{itemize}

\sphinxstepscope


\chapter{Librerie}
\label{\detokenize{ch/programming/libraries:librerie}}\label{\detokenize{ch/programming/libraries::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Definizione del concetto

\item {} 
\sphinxAtStartPar
librerie “standard”, scritte da qualcun’altro

\item {} 
\sphinxAtStartPar
scrivere una libreria

\end{itemize}

\sphinxstepscope


\part{Introduzione al calcolo numerico}

\sphinxstepscope


\chapter{Introduzione al calcolo scientifico}
\label{\detokenize{ch/numerics:introduzione-al-calcolo-scientifico}}\label{\detokenize{ch/numerics:book-numerics-hs}}\label{\detokenize{ch/numerics::doc}}
\sphinxAtStartPar
In questa introduzione al calcolo numerico, vengono presentati alcuni algoritmi. Dove sensato, viene implementata la versione elementare di alcuni di questi algoritmi. Per usi non didattici, e quando possibile, si raccomanda l’uso di algoritmi implementati in librerie disponibili, per questioni di tempo ed efficienza: è lavoro già fatto, da persone che lo sanno fare meglio di noi, controllato, migliorato nel corso degli anni, ottimizzato per ogni sistema e spesso in linguaggi di programmazione diversi da Python, come C o Fortran.

\sphinxAtStartPar
In questa introduzione viene fatto affidamento e uso di alcune librerie disponibili per Python:
\begin{itemize}
\item {} 
\sphinxAtStartPar
librerie con algoritmi e strumenti matematici per il calcolo numerico: \sphinxhref{https://numpy.org}{NumPy}, \sphinxhref{https://scipy.org}{SciPy},…

\item {} 
\sphinxAtStartPar
librerie per la creazione di grafici: \sphinxhref{https://matplotlib.org}{Matplotlib}, \sphinxhref{https://plotly.com}{Plotly},…

\item {} 
\sphinxAtStartPar
librerie per l’analisi dati e la statistica: \sphinxhref{https::/pandas.pydata.org}{pandas},…

\item {} 
\sphinxAtStartPar
librerie per il machine learning: \sphinxhref{https://scikit-learn.org}{sci\sphinxhyphen{}kit}, \sphinxhref{https://pytorch.org}{PyTorch},…

\item {} 
\sphinxAtStartPar
…

\end{itemize}
\subsubsection*{Introduzione al calcolo numerico}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Equazioni lineari

\item {} 
\sphinxAtStartPar
Equazioni non lineari

\item {} 
\sphinxAtStartPar
Approssimazione di funzioni

\item {} 
\sphinxAtStartPar
Derivate

\item {} 
\sphinxAtStartPar
Integrali

\item {} 
\sphinxAtStartPar
Equazioni differenziali ordinarie:
\begin{itemize}
\item {} 
\sphinxAtStartPar
problema di Cauchy ai valori iniziali

\item {} 
\sphinxAtStartPar
problema ai valori al contorno

\end{itemize}

\item {} 
\sphinxAtStartPar
Ottimizzazione, vincolata e non

\end{itemize}
\subsubsection*{Metodi per la statistica}
\subsubsection*{Introduzione al machine learning}

\sphinxstepscope


\section{Sistemi lineari}
\label{\detokenize{ch/numerics/linear:sistemi-lineari}}\label{\detokenize{ch/numerics/linear::doc}}
\sphinxAtStartPar
La soluzione di sistemi lineari è un problema che compare in molte altre applicazioni di calcolo numerico.



\sphinxAtStartPar
\sphinxstylestrong{Formalismo matriciale.} Con il formalismo matriciale, un sistema di equazioni lineari può essere scritto come
\begin{equation*}
\begin{split}\mathbf{A} \mathbf{x} = \mathbf{b}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Classificazione.} In generale, i sistemi di equazioni lineari possono essere classificati:
\begin{itemize}
\item {} 
\sphinxAtStartPar
in base al numero di incognite \(n_u\) ed equazioni indipendenti \(n_e\): \(n_e = n_u\) sistemi determinati con un’unica soluzione; \(n_e > n_u\) sistemi sovradeterminati: con nessuna soluzione in generale; \(n_e < n_u\) sistemi indeterminati, con infinite soluzioni in generale

\item {} 
\sphinxAtStartPar
in base alla “struttura” del sistema:
\begin{itemize}
\item {} 
\sphinxAtStartPar
diagonale, tridiagonale, …

\end{itemize}

\item {} 
\sphinxAtStartPar
in base al numero di coefficienti non\sphinxhyphen{}nulli della matrice \(\mathbf{A}\): sistemi con matrice \(\mathbf{A}\) piena o \sphinxstylestrong{sparsa}; questa distinzione non è netta, ma il più delle volte risulta chiara dalla particolare applicazione/metodo.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Algoritmi.} Esistono due grandi classi di metodi/algoritmi per la soluzione di sistemi lineari:
\begin{itemize}
\item {} 
\sphinxAtStartPar
i \sphinxstylestrong{metodi diretti}, che si basano su una fattorizzazione della matrice

\item {} 
\sphinxAtStartPar
i \sphinxstylestrong{metodi indiretti}, che si basano sul calcolo di prodotti matrice\sphinxhyphen{}vettore

\end{itemize}


\subsection{Sistemi lineari quadrati con matrici piene}
\label{\detokenize{ch/numerics/linear:sistemi-lineari-quadrati-con-matrici-piene}}
\sphinxAtStartPar
In questa sezione si discute la soluzione di sistemi lineari quadrati con matrici piene con le funzoni disponibili nella libreria NumPy.


\subsubsection{Esempio 1. Sistema quadrato determinato}
\label{\detokenize{ch/numerics/linear:esempio-1-sistema-quadrato-determinato}}
\sphinxAtStartPar
Il sistema lineare
\begin{equation*}
\begin{split}\begin{cases}
  x_1 + 2 \, x_2 = 0 \\
  x_1 + x_3 = -1 \\
  x_1 + x_2 + x_3 = 1 \\
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
può essere riscritto con il formalismo matriciale nella forma \(\mathbf{A} \mathbf{x} = \mathbf{b}\),
\begin{equation*}
\begin{split}
\underbrace{\begin{bmatrix} 1 & 2 & 0 \\ 1 & 0 & 1 \\ 1 & 1 & 1 \end{bmatrix}}_{\mathbf{A}}
\underbrace{\begin{bmatrix} x_1 \\ x_2 \\ x_3 \end{bmatrix}}_{\mathbf{x}} =
\underbrace{\begin{bmatrix} 0 \\ -1 \\ 1 \end{bmatrix}}_{\mathbf{b}}
\end{split}
\end{equation*}
\sphinxAtStartPar
e risolto grazie alla funzione \(\texttt{solve(A, b)}\) della libreria \(\texttt{numpy.linalg}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with full square non\PYGZhy{}singular matrices}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{         b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sol, x: [\PYGZhy{}4.  2.  3.]
Proof : Ax = [ 0. \PYGZhy{}1.  1.]
         b = [ 0. \PYGZhy{}1.  1.]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Esempio 2. Sistemi quadrati non determinati}
\label{\detokenize{ch/numerics/linear:esempio-2-sistemi-quadrati-non-determinati}}
\sphinxAtStartPar
I sistemi lineari
\begin{equation*}
\begin{split}\begin{cases}
  x_1 + 2 \, x_2 = 1 \\
  x_1 + x_3 = -1 \\
  2 x_1 + 2 \, x_2 + x_3 = 1 \\
\end{cases}
\qquad , \qquad
\begin{cases}
  x_1 + 2 \, x_2 = 0 \\
  x_1 + x_3 = -1 \\
  2 x_1 + 2 \, x_2 + x_3 = 1 \\
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
sono due sistemi quadrati non determinati. Il primo sistema non ha soluzioni, mentre il secondo ne ha infinite della forma
\begin{equation*}
\begin{split}(x_1, x_2, x_3) = (-2, 1, 1) + \alpha (2, -1, -2) \ , \quad \alpha \in \mathbb{R} \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Dopo aver riscritto i sistemi lineari con il formalismo matriciale, si può provare a risolverli usando la funzione \(\texttt{solve(A, b)}\) della libreria \(\texttt{numpy.linalg}\). In entrambi i casi, la funzione \(\texttt{solve(A,b)}\) resitiuisce un errore, segnalando che la matrice del sistema lineare è singolare, definizione equivalente di sistemi non determinati.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{dare interpretazione geometrica, fare grafico?}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} \sphinxstyleemphasis{spiegare motivo?}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Esistono algoritmi che trovano almeno una soluzione nel caso in cui ne esistano infinite?}: discutere gli algoritmi implementati nella funzione \(numpy.linalg.solve()\) e rimandare alla documentazione della libreria; discutere altri algoritmi che rendono possibile trovare una soluzione

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Esistono algoritmi che trovano una soluzione approssimata nel caso in cui non ne esistano?}: \sphinxstylestrong{minimi quadrati}, minimizzano l’errore, dare un’interpretazione geometrica

\end{itemize}

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with full square singular matrices}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{2.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} b = np.array([0.,\PYGZhy{}1.,1.])}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{         b = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{b}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{LinAlgError}\PYG{g+gWhitespace}{                               }Traceback (most recent call last)
\PYG{n}{Cell} \PYG{n}{In}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{line} \PYG{l+m+mi}{11}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{8} \PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gWhitespace}{      }\PYG{l+m+mi}{9} \PYG{c+c1}{\PYGZsh{} b = np.array([0.,\PYGZhy{}1.,1.])}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{11} \PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{13} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{14} \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Proof : Ax = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{+w}{ }\PYG{o}{@}\PYG{+w}{ }\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} Check that Ax = b}

\PYG{n+nn}{File \PYGZlt{}\PYGZus{}\PYGZus{}array\PYGZus{}function\PYGZus{}\PYGZus{} internals\PYGZgt{}:200,} in \PYG{n+ni}{solve}\PYG{n+nt}{(*args, **kwargs)}

\PYG{n+nn}{File \PYGZti{}/.local/lib/python3.8/site\PYGZhy{}packages/numpy/linalg/linalg.py:386,} in \PYG{n+ni}{solve}\PYG{n+nt}{(a, b)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{384} \PYG{n}{signature} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DD\PYGZhy{}\PYGZgt{}D}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{isComplexType}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dd\PYGZhy{}\PYGZgt{}d}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{385} \PYG{n}{extobj} \PYG{o}{=} \PYG{n}{get\PYGZus{}linalg\PYGZus{}error\PYGZus{}extobj}\PYG{p}{(}\PYG{n}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{)}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{386} \PYG{n}{r} \PYG{o}{=} \PYG{n}{gufunc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{signature}\PYG{o}{=}\PYG{n}{signature}\PYG{p}{,} \PYG{n}{extobj}\PYG{o}{=}\PYG{n}{extobj}\PYG{p}{)}
\PYG{g+gWhitespace}{    }\PYG{l+m+mi}{388} \PYG{k}{return} \PYG{n}{wrap}\PYG{p}{(}\PYG{n}{r}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n}{result\PYGZus{}t}\PYG{p}{,} \PYG{n}{copy}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nn}{File \PYGZti{}/.local/lib/python3.8/site\PYGZhy{}packages/numpy/linalg/linalg.py:89,} in \PYG{n+ni}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{n+nt}{(err, flag)}
\PYG{g+gWhitespace}{     }\PYG{l+m+mi}{88} \PYG{k}{def} \PYG{n+nf}{\PYGZus{}raise\PYGZus{}linalgerror\PYGZus{}singular}\PYG{p}{(}\PYG{n}{err}\PYG{p}{,} \PYG{n}{flag}\PYG{p}{)}\PYG{p}{:}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{89}     \PYG{k}{raise} \PYG{n}{LinAlgError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Singular matrix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+ne}{LinAlgError}: Singular matrix
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Matrici sparse}
\label{\detokenize{ch/numerics/linear:matrici-sparse}}
\sphinxAtStartPar
Una matrice sparsa ha un elevato numero di elementi nulli. Una matrice sparsa viene definita in maniera efficiente salvando in memoria solo gli elementi non nulli (\sphinxstylestrong{limiti di memoria}); gli algoritmi per le matrici sparse risultano spesso efficienti perché evitano un molte operazioni che darebbero risultati parziali nulli (\sphinxstylestrong{velocità}).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} dire due parole sui formati

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} fare esempio di calcolo del prodotto matrice vettore per matrici sparse

\end{itemize}


\subsubsection{Esempio 1 \sphinxhyphen{} Matrice di rigidezza di elementi finiti}
\label{\detokenize{ch/numerics/linear:esempio-1-matrice-di-rigidezza-di-elementi-finiti}}
\sphinxAtStartPar
Il sistema lineare
\begin{equation*}
\begin{split}\begin{bmatrix} 2 & -1 & 0 & 0 & 0 \\ -1 & 2 & -1 & 0 & 0 \\ 0 & -1 & 2 & -1 & 0 \\ 0 & 0 & -1 & 2 & -1 \\ 0 & 0 & 0 & -1  & 2 \end{bmatrix} \begin{bmatrix} x_0 \\ x_1 \\ x_2 \\ x_3 \\ x_4 \end{bmatrix} = \begin{bmatrix} 1 \\ 1 \\ 1 \\ 1 \\ 1 \end{bmatrix} \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
è descritto da una matrice, \(N=5\), \(N \times N = 25\), che ha \(N+(N-1)+(N-1) = 13\) elementi non nulli. Il rapporto tra il numero di elementi non nulli e il numero di elementi totali è \(\frac{3N-2}{N^2} \sim \frac{3}{N}\). Al crescere della dimensione del problema, la matrice \(\mathbf{A}\) diventa sempre più sparsa e diventa sempre più conveniente definirla come matrice sparsa, ed usare gli algoritmi pensati per questo tipo di matrici.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Linear systems with square non\PYGZhy{}singular matrices, in sparse format}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{from} \PYG{n+nn}{scipy} \PYG{k+kn}{import} \PYG{n}{sparse}

\PYG{c+c1}{\PYGZsh{} Printout level: the higher the number, the more verbose the script}
\PYG{n}{printout\PYGZus{}level} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{n}{n\PYGZus{}nodes} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{i\PYGZus{}nodes} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Build sparse stiffness matrix, I: row indices, J: col indices, E: matrix elems}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{i\PYGZus{}nodes}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{J} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{i\PYGZus{}nodes}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{n}{i\PYGZus{}nodes}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{*}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{p}{(}\PYG{n}{n\PYGZus{}nodes}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{coo\PYGZus{}array}\PYG{p}{(}\PYG{p}{(}\PYG{n}{E}\PYG{p}{,} \PYG{p}{(}\PYG{n}{I}\PYG{p}{,}\PYG{n}{J}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{tocsr}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{p}{(} \PYG{n}{printout\PYGZus{}level} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{50} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} print matrix in sparse format}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ I: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{I}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ J: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{J}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ E: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{E}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ A:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    
\PYG{k}{if} \PYG{p}{(} \PYG{n}{printout\PYGZus{}level} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{60} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} convert and primt matrix in full format}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ A.todense(): }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{A}\PYG{o}{.}\PYG{n}{todense}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} RHS}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Solve linear system}
\PYG{n}{x} \PYG{o}{=} \PYG{n}{sparse}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{spsolve}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Sol, x: [2.5 4.  4.5 4.  2.5]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\section{Equazioni algebriche non lineari}
\label{\detokenize{ch/numerics/nonlinear:equazioni-algebriche-non-lineari}}\label{\detokenize{ch/numerics/nonlinear::doc}}
\sphinxAtStartPar
Questa sezione si occupa della soluzione delle equazioni algebriche non lineari, distinguendo le equazioni non lineari con una sola incognita \(x \in \mathbb{R}\)
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e i sistemi di equazioni non lineari con un numero di incognite pari al numero di equazione,
\begin{equation*}
\begin{split}\mathbf{f}(\mathbf{x}) = \mathbf{0} \ .\end{split}
\end{equation*}

\subsection{Equazioni non lineari}
\label{\detokenize{ch/numerics/nonlinear:equazioni-non-lineari}}
\sphinxAtStartPar
Vengono presentati i metodi di bisezione e di Newton per la soluzione di un’equazione non lineare,
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
e applicati alla soluzione del problema con \(f(x) = e^x + x\), la cui derivata è nota e immediata da calcolare \(f'(x) = e^x + 1\). L’espressione della derivata verrà utilizzata nel metodo di Newton.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Import libaries \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{time}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example. f(x) = e\PYGZca{}x + x}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Function f and its derivative}
\PYG{n}{f}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{x}
\PYG{n}{df} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsubsection{Metodo di bisezione}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-bisezione}}
\sphinxAtStartPar
Il metodo di bisezione per la ricerca degli zeri di una funzione continua \(F(x)\) si basa sul teorema dei valori intermedi per le funzioni continue.

\sphinxAtStartPar
Dati due numeri reali \(a\), \(b\) tali che \(f(a) \, f(b) < 0\), allora esiste un punto \(c \in (a,b)\) tale che \(f(c) = 0\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define bisection\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear scalar equations with bisection method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{bisection\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing the bisection method for scalar equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}

    \PYG{k}{if} \PYG{p}{(} \PYG{o+ow}{not} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection algorithm can}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t start, f(a)f(b)\PYGZgt{}= 0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
        \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fx}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        
            \PYG{k}{if} \PYG{p}{(} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{*} \PYG{n}{f}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,c]}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{x}
            \PYG{k}{else}\PYG{p}{:}  \PYG{c+c1}{\PYGZsh{} new range [a,b]}
                \PYG{n}{a} \PYG{o}{=} \PYG{n}{x}
        
            \PYG{c+c1}{\PYGZsh{} Update solution and residual}
            \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mf}{.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}
            \PYG{n}{fx} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} Update n.iter}
            \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{fx}\PYG{p}{)}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use bisection\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Find 2 values so that \PYGZdl{}f(a) f(b) \PYGZlt{} 0\PYGZdl{}}
\PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{,} \PYG{l+m+mf}{0.}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{bisection\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Bisection method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Bisection method summary: 
Convergence reached
Sol, x = \PYGZhy{}0.567143440246582
residual     : \PYGZhy{}2.348157265297246e\PYGZhy{}07
n. iterations: 20
elapsed time : 0.0005495548248291016
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Metodo di Newton}
\label{\detokenize{ch/numerics/nonlinear:metodo-di-newton}}
\sphinxAtStartPar
Per trovare la soluzione del problema non lineare
\begin{equation*}
\begin{split}f(x) = 0 \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
il metodo di Newton sfrutta l’espansione in serie troncata al primo grado della funzione \(f(x)\), per scrivere
\begin{equation*}
\begin{split}0 = f(x^n + \Delta x) \approx f(x^n) + f'(x^n) \Delta x \end{split}
\end{equation*}
\sphinxAtStartPar
e ottenere l’incremento della soluzione \(\Delta x\) come soluzione del sistema lineare
\begin{equation*}
\begin{split}f'(x^n) \Delta x = -f(x^n)\end{split}
\end{equation*}
\sphinxAtStartPar
e aggiornare la soluzione \(x^{n+1} = x^{n} + \Delta x\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define newton\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear scalar equations with Newton\PYGZsq{}s method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{newton\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{.0}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing Newton\PYGZsq{}s method for scalar equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}
    
    \PYG{c+c1}{\PYGZsh{} Newton algorithm}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Solve linear approximation step, and update solution}
        \PYG{n}{dx} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{res} \PYG{o}{/} \PYG{n}{df}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dx}
    
        \PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate new residual and n. of iter}
        \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use newton\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} import numpy as np   \PYGZsh{} already imported}

\PYG{c+c1}{\PYGZsh{} Parameters of the Newton method, for stopping criteria}
\PYG{c+c1}{\PYGZsh{} tol = 1e\PYGZhy{}6          \PYGZsh{} tolerance on the residual |f(x)| \PYGZlt{} tol}
\PYG{c+c1}{\PYGZsh{} max\PYGZus{}niter = 10      \PYGZsh{} max n. of iterations      niter \PYGZgt{} max\PYGZus{}niter}
\PYG{n}{x0} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{newton\PYGZus{}method\PYGZus{}scalar}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Newton\PYGZsq{}s method summary: 
Convergence reached
Sol, x = \PYGZhy{}0.567143285989123
residual     : 6.927808993140161e\PYGZhy{}09
n. iterations: 3
elapsed time : 0.00041985511779785156
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Sistemi di equazioni non lineari}
\label{\detokenize{ch/numerics/nonlinear:sistemi-di-equazioni-non-lineari}}

\subsubsection{Esempio}
\label{\detokenize{ch/numerics/nonlinear:esempio}}\begin{equation*}
\begin{split}\begin{cases}
    x_1   - x_2 = 0 \\
  - x_1^2 + x_2 = -1
\end{cases}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\mathbf{f}(\mathbf{x}) = \begin{bmatrix} x_1 - x_2 \\ -x_1^2 + x_2 - 1 \end{bmatrix}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\mathbf{f}'(\mathbf{x}) = \begin{bmatrix} 1 & - 1 \\ - 2 x_1 & 1\end{bmatrix}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Example. f(x) = e\PYGZca{}x + x}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Function f and its derivative}
\PYG{n}{f}  \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Define newton\PYGZus{}method\PYGZus{}scalar() function to solve nonlinear systems of equations with Newton\PYGZsq{}s method}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def} \PYG{n+nf}{newton\PYGZus{}method\PYGZus{}system}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{l+m+mf}{.0}\PYG{p}{,} \PYG{n}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Function implementing Newton\PYGZsq{}s method for systems of equations \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
    \PYG{n}{niter} \PYG{o}{=} \PYG{l+m+mi}{0}
    
    \PYG{c+c1}{\PYGZsh{} Newton algorithm}
    \PYG{k}{while} \PYG{p}{(} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{tol} \PYG{o+ow}{and} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Solve linear approximation step, and update solution}
        \PYG{n}{dx} \PYG{o}{=} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{df}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{res}\PYG{p}{)}
        \PYG{n}{x} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dx}
    
        \PYG{c+c1}{\PYGZsh{}\PYGZgt{} Evaluate new residual and n. of iter}
        \PYG{n}{res} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
        \PYG{n}{niter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{} Use newton\PYGZus{}method\PYGZus{}scalar() function to solve the example \PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} import numpy as np   \PYGZsh{} already imported}

\PYG{c+c1}{\PYGZsh{} Parameters of the Newton method, for stopping criteria}
\PYG{c+c1}{\PYGZsh{} tol = 1e\PYGZhy{}6          \PYGZsh{} tolerance on the residual |f(x)| \PYGZlt{} tol}
\PYG{c+c1}{\PYGZsh{} max\PYGZus{}niter = 10      \PYGZsh{} max n. of iterations      niter \PYGZgt{} max\PYGZus{}niter}
\PYG{n}{x0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{]}\PYG{p}{)}

\PYG{n}{t1} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{x}\PYG{p}{,} \PYG{n}{res}\PYG{p}{,} \PYG{n}{niter}\PYG{p}{,} \PYG{n}{max\PYGZus{}niter} \PYG{o}{=} \PYG{n}{newton\PYGZus{}method\PYGZus{}system}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{df}\PYG{p}{,} \PYG{n}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Newton}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{s method summary: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{niter} \PYG{o}{\PYGZlt{}} \PYG{n}{max\PYGZus{}niter} \PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Convergence reached}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Sol, x = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{x}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{max n.iter reached without convergence}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{residual     : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n. iterations: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{niter}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{elapsed time : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{t1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Newton\PYGZsq{}s method summary: 
Convergence reached
Sol, x = [\PYGZhy{}0.61803399 \PYGZhy{}0.61803399]
residual     : [ 0.00000000e+00 \PYGZhy{}2.10942375e\PYGZhy{}13]
n. iterations: 4
elapsed time : 0.0006754398345947266
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} L’algoritmo di Newton trova solo una soluzione del problema. Cercare le altre soluzioni cambiando il tentativo iniziale.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{todo} … altro?

\end{itemize}

\sphinxstepscope


\section{Approssimazione di funzioni}
\label{\detokenize{ch/numerics/approximation:approssimazione-di-funzioni}}\label{\detokenize{ch/numerics/approximation::doc}}

\subsection{Interpolazione}
\label{\detokenize{ch/numerics/approximation:interpolazione}}

\subsection{Regressione}
\label{\detokenize{ch/numerics/approximation:regressione}}
\sphinxstepscope


\section{Derivate di funzioni}
\label{\detokenize{ch/numerics/derivatives:derivate-di-funzioni}}\label{\detokenize{ch/numerics/derivatives::doc}}

\subsection{Differenze finite}
\label{\detokenize{ch/numerics/derivatives:differenze-finite}}
\sphinxAtStartPar
Il calcolo della derivata di una funzione \(f(x)\) derivabile in un punto \(x_0\) può essere svolto utilizzando l’espansione locale in serie di Taylor di una funzione.


\subsubsection{Derivata prima}
\label{\detokenize{ch/numerics/derivatives:derivata-prima}}
\sphinxAtStartPar
Usando le espansioni
\begin{equation*}
\begin{split}f(x + \Delta x) = f(x) + f'(x) \Delta x + f''(x) \frac{\Delta x^2}{2} + f'''(x) \frac{\Delta x^3}{3!} + o(x^3)\end{split}
\end{equation*}\begin{equation*}
\begin{split}f(x - \Delta x) = f(x) - f'(x) \Delta x + f''(x) \frac{\Delta x^2}{2} - f'''(x) \frac{\Delta x^3}{3!} + o(x^3)\end{split}
\end{equation*}
\sphinxAtStartPar
si possono ricavare gli schemi del primo ordine
\begin{equation*}
\begin{split}f'(x) = \frac{f(x+\Delta x) - f(x)}{\Delta x} + o(\Delta x)\end{split}
\end{equation*}\begin{equation*}
\begin{split}f'(x) = \frac{f(x+\Delta x) - f(x)}{\Delta x} + o(\Delta x)\end{split}
\end{equation*}
\sphinxAtStartPar
e lo schema del secondo ordine usando le differenze centrate
\begin{equation*}
\begin{split}f'(x) = \dfrac{f(x+\Delta x) - f(x-\Delta x)}{2 \Delta x} + o(\Delta x^2) \end{split}
\end{equation*}

\subsubsection{Derivata seconda}
\label{\detokenize{ch/numerics/derivatives:derivata-seconda}}
\sphinxAtStartPar
Usando le stesse espansioni in serie, si può ottenere uno schema del secondo ordine per la derivata seconda
\begin{equation*}
\begin{split}f''(x) = \frac{f(x+\Delta x) - 2 f(x) + f(x-\Delta x)}{\Delta x^2} + o(\Delta x^2)\end{split}
\end{equation*}
\sphinxstepscope


\section{Integrali}
\label{\detokenize{ch/numerics/integrals:integrali}}\label{\detokenize{ch/numerics/integrals::doc}}

\subsection{Integrazione di Newton\sphinxhyphen{}Cotes}
\label{\detokenize{ch/numerics/integrals:integrazione-di-newton-cotes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Formula del punto medio

\item {} 
\sphinxAtStartPar
Formula del trapezio

\end{itemize}


\subsection{Integrazione di Gauss}
\label{\detokenize{ch/numerics/integrals:integrazione-di-gauss}}
\sphinxAtStartPar
L’integrazione di Gauss permette di calcolare in maniera esatta l’integrale di una funzione polinomiale \(p^(n)(x)\) su un intervallo \([a,b]\), come somma pesata della funzione valuatata in alcuni punti dell’intervallo,
\begin{equation*}
\begin{split}\int_a^b p^{(n)}(x) dx = \sum_{g} w_g f(x_g) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Per motivi di generalizzazione dell’algoritmo, nella definizione dei \sphinxstylestrong{pesi} \(w_i\) e dei \sphinxstylestrong{nodi di Gauss} \(x_i\), l’integrale viene riportato all’integrale su un intervallo di riferimento, tramite una trasformazione di coordinate.

\sphinxAtStartPar
Per domini 1D, l’intervallo di riferimento per la quadratura di Gauss è l’intervallo \(\xi = [-1, 1]\) e il cambio di variabili è
\begin{equation*}
\begin{split}x = \frac{a+b}{2} + \frac{b-a}{2}(\xi - 1) \ ,\end{split}
\end{equation*}
\sphinxAtStartPar
così che l’integrale originale può essere scritto come
\begin{equation*}
\begin{split}\begin{aligned}
\int_{x=a}^b p^{(n)}(x) dx & = \int_{\xi = -1}^{1} p^(n) (x(\xi)) \dfrac{d x}{d\xi} d \xi = \\
 & = \dfrac{b-a}{2} \int_{\xi=-1}^{1} p^{(n)}(x(\xi)) d \xi = \dfrac{b-a}{2} \sum_{g} w_g \, p^{(n)}\left(x(\xi_g)\right)
\end{aligned}\end{split}
\end{equation*}
\sphinxstepscope


\section{Equazioni differenziali ordinarie}
\label{\detokenize{ch/numerics/ode:equazioni-differenziali-ordinarie}}\label{\detokenize{ch/numerics/ode::doc}}
\sphinxstepscope


\subsection{Problemi di Cauchy ai valori iniziali}
\label{\detokenize{ch/numerics/ode-cauchy:problemi-di-cauchy-ai-valori-iniziali}}\label{\detokenize{ch/numerics/ode-cauchy::doc}}

\subsubsection{Approccio a un problema di Cauchy di ordine \protect\(n\protect\)}
\label{\detokenize{ch/numerics/ode-cauchy:approccio-a-un-problema-di-cauchy-di-ordine-n}}
\sphinxAtStartPar
Un problema di Cauchy di ordine \(n\)
\begin{equation*}
\begin{split}\begin{cases}
  F(y^{(n)}(x), y^{(n-1)}(x), \dots, y'(x), y(x), x) = 0 \\
  y(x_0) = y^0 \\
  y'(x_0) = y'^0 \\
  \dots \\
  y^{(n-1)}(x_0) = y^{(n-1),0}
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
con funzione incognita \(y(x): D \in \mathbb{R} \rightarrow \mathbb{R}\), può essere riscritto come un problema di \sphinxstyleemphasis{“ordine 1”} per la funzione incognita \(\mathbf{z}(x): D \in \mathbb{R} \rightarrow \mathbb{R}^n\), definita come
\begin{equation*}
\begin{split}\mathbf{z}(x) = (z_0(x), z_1(x), \dots z_{n-1}(x)) := (y(x), y'(x), \dots, y^{(n-1)}(x)) \ .\end{split}
\end{equation*}
\sphinxAtStartPar
Esplicitando le relazioni tra le componenti di \(\mathbf{z}(x)\) e le derivate della funzione \(y(x)\), \(z_{k}(x) = y^{(k)}(x) = {y^{(k-1)}}'(x) = z'_{k-1}(x)\), il problema di Cauchy può essere riformulato come
\begin{equation*}
\begin{split}\begin{cases}
z'_0 - z_1 = 0 \\
z'_1 - z_2 = 0 \\
\dots \\
z'_{n-2} - z_{n-1} = 0 \\
F(z'_{n-1}(x), z_{n-1}(x), \dots, z_1(x), z_0(x)) = 0 \ ,
\end{cases}
\qquad , \qquad
\text{i.c.} \quad
\begin{cases}
z_0(x_0) = y^0 \\
z_1(x_0) = y'^0 \\
\dots \\
z_{n-1}(x_0) = y^{(n-1),0}
\end{cases}
\end{split}
\end{equation*}
\sphinxAtStartPar
che può essere riscritto con il formalismo vettoriale come
\begin{equation*}
\begin{split}\begin{cases}
  \mathbf{F}(\mathbf{z}'(x), \mathbf{z}) = \mathbf{0} \\
  \mathbf{z}(x_0) = \mathbf{z}_0
\end{cases}\end{split}
\end{equation*}

\subsubsection{Caratteristiche (cenni)}
\label{\detokenize{ch/numerics/ode-cauchy:caratteristiche-cenni}}\begin{itemize}
\item {} 
\sphinxAtStartPar
accuratezza, consistenza, convergenza

\item {} 
\sphinxAtStartPar
stabilità: 0\sphinxhyphen{}, A\sphinxhyphen{} condizionata e incondizionata

\end{itemize}


\subsubsection{Schemi numerici}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici}}

\paragraph{Schemi numerici a un passo}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-a-un-passo}}

\paragraph{Schemi numerici multi\sphinxhyphen{}step}
\label{\detokenize{ch/numerics/ode-cauchy:schemi-numerici-multi-step}}
\sphinxstepscope


\subsection{Problemi al contorno}
\label{\detokenize{ch/numerics/ode-boundary:problemi-al-contorno}}\label{\detokenize{ch/numerics/ode-boundary::doc}}

\subsubsection{Differenze finite}
\label{\detokenize{ch/numerics/ode-boundary:differenze-finite}}

\subsubsection{Elementi finiti}
\label{\detokenize{ch/numerics/ode-boundary:elementi-finiti}}

\subsubsection{Volumi finiti}
\label{\detokenize{ch/numerics/ode-boundary:volumi-finiti}}
\sphinxstepscope


\section{Ottimizzazione}
\label{\detokenize{ch/numerics/optimization:ottimizzazione}}\label{\detokenize{ch/numerics/optimization::doc}}
\sphinxAtStartPar
Le tecniche di ottimizzazione sono alla base di molti metodi di interesse, dall’approssimazione di funzioni, alla regolazione e controllo, agli algoritmi usati in intelligenza artificiale

\sphinxstepscope


\section{Introduzione ai metodi in AI}
\label{\detokenize{ch/ai:introduzione-ai-metodi-in-ai}}\label{\detokenize{ch/ai:book-ai-hs}}\label{\detokenize{ch/ai::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
SL, supervised learning: regression and classification

\item {} 
\sphinxAtStartPar
UL, unsupervised learning: clustering

\item {} 
\sphinxAtStartPar
ML, machine learning: control

\end{itemize}

\sphinxstepscope


\part{Supporto tecnico}

\sphinxstepscope


\chapter{Supporto tecnico}
\label{\detokenize{ch/support:supporto-tecnico}}\label{\detokenize{ch/support:programming-hs-support-hs}}\label{\detokenize{ch/support::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
git

\item {} 
\sphinxAtStartPar
Servizi Google

\item {} 
\sphinxAtStartPar
TeX

\end{itemize}







\renewcommand{\indexname}{Index}
\printindex
\end{document}